<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/ContactsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/ContactsFragment.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.contacts&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.TextWatcher&#10;import android.view.HapticFeedbackConstants&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AutoCompleteTextView&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.net.toUri&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.firstaidapp.R&#10;import com.example.firstaidapp.data.models.ContactType&#10;import com.example.firstaidapp.data.models.EmergencyContact&#10;import com.example.firstaidapp.databinding.FragmentContactsBinding&#10;import com.example.firstaidapp.utils.LocationHelper&#10;import com.google.android.material.snackbar.Snackbar&#10;import kotlinx.coroutines.launch&#10;&#10;class ContactsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentContactsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var viewModel: ContactsViewModel&#10;    private lateinit var contactsAdapter: ContactsAdapter&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted, can make direct call&#10;            Snackbar.make(binding.root, &quot;Permission granted! Tap call button again to make direct call&quot;, Snackbar.LENGTH_SHORT).show()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Using dialer instead&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    private val requestLocationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        if (permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true ||&#10;            permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true) {&#10;            // Permission granted, get location&#10;            detectLocationAndSetState()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Location permission denied. Please select your state manually.&quot;, Snackbar.LENGTH_LONG).show()&#10;            showManualStateSelection()&#10;        }&#10;    }&#10;&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentContactsBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        setupViewModel()&#10;        setupRecyclerView()&#10;        setupObservers()&#10;        setupClickListeners()&#10;        setupSearchFunctionality()&#10;&#10;        // Only show state dialog if no state has been selected before&#10;        if (!viewModel.isStateSelected()) {&#10;            showStateDialogIfNeeded()&#10;        }&#10;    }&#10;&#10;    private fun setupViewModel() {&#10;        val factory = ContactsViewModelFactory(requireActivity().application)&#10;        viewModel = ViewModelProvider(this, factory)[ContactsViewModel::class.java]&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        contactsAdapter = ContactsAdapter { contact -&gt;&#10;            makePhoneCall(contact.phoneNumber)&#10;        }&#10;&#10;        binding.rvContacts.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = contactsAdapter&#10;        }&#10;    }&#10;&#10;    private fun setupObservers() {&#10;        // Observe all contacts (filtered by state)&#10;        viewModel.allContacts.observe(viewLifecycleOwner) { contacts -&gt;&#10;            // Only update if no search is active&#10;            if (binding.etSearchContacts.text.isNullOrEmpty()) {&#10;                contactsAdapter.submitList(contacts)&#10;            }&#10;        }&#10;&#10;        // Observe filtered contacts (for search results)&#10;        viewModel.filteredContacts.observe(viewLifecycleOwner) { filteredContacts -&gt;&#10;            // Only update if search is active and we have filtered results&#10;            if (!binding.etSearchContacts.text.isNullOrEmpty() &amp;&amp; filteredContacts.isNotEmpty()) {&#10;                contactsAdapter.submitList(filteredContacts)&#10;            }&#10;        }&#10;&#10;        // Observe selected state to update button text&#10;        viewModel.selectedState.observe(viewLifecycleOwner) { state -&gt;&#10;            updateStateButtonText(state)&#10;        }&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.btnSettings.setOnClickListener {&#10;            // Use basic navigation instead of SafeArgs for compatibility&#10;            findNavController().navigate(R.id.navigation_settings)&#10;        }&#10;&#10;        binding.fabAddContact.setOnClickListener {&#10;            showAddContactDialog()&#10;        }&#10;        &#10;        binding.btnSelectState.setOnClickListener {&#10;            showStateSelectionDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupSearchFunctionality() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return&#10;&#10;        binding.etSearchContacts.addTextChangedListener(object : TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                // Add null check&#10;                if (_binding == null) return&#10;&#10;                val query = s.toString()&#10;&#10;                // Removed all animations - immediate search instead&#10;                if (query.isNotEmpty()) {&#10;                    try {&#10;                        viewModel.searchContacts(query)&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                } else {&#10;                    try {&#10;                        viewModel.clearSearch()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;            }&#10;&#10;            override fun afterTextChanged(s: Editable?) {}&#10;        })&#10;&#10;        // Removed focus animations - basic functionality only&#10;        binding.etSearchContacts.setOnFocusChangeListener { view, hasFocus -&gt;&#10;            if (_binding == null) return@setOnFocusChangeListener&#10;            // No animations - just basic elevation change&#10;            if (hasFocus) {&#10;                view.elevation = 8f&#10;            } else {&#10;                view.elevation = 2f&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showAddContactDialog() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_add_contact, null)&#10;&#10;            val dialog = AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;&#10;            // Get dialog views&#10;            val etContactName = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etContactName)&#10;            val etPhoneNumber = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etPhoneNumber)&#10;            val etRelationship = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etRelationship)&#10;            val spinnerContactType = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.spinnerContactType)&#10;            val etNotes = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etNotes)&#10;            val btnImportFromPhone = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnImportFromPhone)&#10;            val btnCancel = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnCancel)&#10;            val btnSave = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnSave)&#10;&#10;            // Null checks for all views&#10;            if (etContactName == null || etPhoneNumber == null || spinnerContactType == null ||&#10;                btnImportFromPhone == null || btnCancel == null || btnSave == null) {&#10;                return&#10;            }&#10;&#10;            // Setup contact type dropdown&#10;            setupContactTypeDropdown(spinnerContactType)&#10;&#10;            // Setup click listeners with null checks&#10;            btnImportFromPhone.setOnClickListener {&#10;                dialog.dismiss()&#10;                if (isAdded &amp;&amp; _binding != null) {&#10;                    openPhoneContactsSelection()&#10;                }&#10;            }&#10;&#10;            btnCancel.setOnClickListener {&#10;                dialog.dismiss()&#10;            }&#10;&#10;            btnSave.setOnClickListener {&#10;                if (!isAdded || _binding == null) {&#10;                    dialog.dismiss()&#10;                    return@setOnClickListener&#10;                }&#10;&#10;                val name = etContactName.text?.toString()?.trim() ?: &quot;&quot;&#10;                val phone = etPhoneNumber.text?.toString()?.trim() ?: &quot;&quot;&#10;                val relationship = etRelationship.text?.toString()?.trim() ?: &quot;&quot;&#10;                val typeString = spinnerContactType.text?.toString() ?: &quot;Personal&quot;&#10;                val notes = etNotes.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;                if (validateContactInput(name, phone)) {&#10;                    val contactType = when (typeString) {&#10;                        &quot;Emergency Service&quot; -&gt; ContactType.EMERGENCY_SERVICE&#10;                        &quot;Poison Control&quot; -&gt; ContactType.POISON_CONTROL&#10;                        &quot;Hospital&quot; -&gt; ContactType.HOSPITAL&#10;                        &quot;Police&quot; -&gt; ContactType.POLICE&#10;                        &quot;Fire Department&quot; -&gt; ContactType.FIRE_DEPARTMENT&#10;                        &quot;Family&quot; -&gt; ContactType.FAMILY&#10;                        &quot;Doctor&quot; -&gt; ContactType.DOCTOR&#10;                        &quot;Veterinarian&quot; -&gt; ContactType.VETERINARIAN&#10;                        &quot;Other&quot; -&gt; ContactType.OTHER&#10;                        else -&gt; ContactType.PERSONAL&#10;                    }&#10;&#10;                    val contact = EmergencyContact(&#10;                        name = name,&#10;                        phoneNumber = phone,&#10;                        relationship = relationship,&#10;                        type = contactType,&#10;                        notes = notes,&#10;                        // Assign currently selected state for manual contacts&#10;                        state = viewModel.selectedState.value ?: &quot;National&quot;&#10;                    )&#10;&#10;                    try {&#10;                        viewModel.addContact(contact)&#10;&#10;                        // Removed animation - show immediate success message&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Contact added successfully!&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;&#10;                        dialog.dismiss()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Error adding contact: ${e.message}&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error opening add contact dialog&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupContactTypeDropdown(spinner: AutoCompleteTextView) {&#10;        val contactTypes = arrayOf(&#10;            &quot;Personal&quot;,&#10;            &quot;Family&quot;,&#10;            &quot;Emergency Service&quot;,&#10;            &quot;Hospital&quot;,&#10;            &quot;Police&quot;,&#10;            &quot;Fire Department&quot;,&#10;            &quot;Poison Control&quot;,&#10;            &quot;Doctor&quot;,&#10;            &quot;Veterinarian&quot;,&#10;            &quot;Other&quot;&#10;        )&#10;&#10;        val adapter = android.widget.ArrayAdapter(&#10;            requireContext(),&#10;            android.R.layout.simple_dropdown_item_1line,&#10;            contactTypes&#10;        )&#10;&#10;        spinner.setAdapter(adapter)&#10;        spinner.setText(&quot;Personal&quot;, false)&#10;    }&#10;&#10;    private fun openPhoneContactsSelection() {&#10;        // Add safety checks to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // PhoneContactsActivity was removed - show message that feature is not available&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Phone contacts import not available in this version&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error accessing phone contacts&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun makePhoneCall(phoneNumber: String) {&#10;        // Add comprehensive null checks and error handling&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // Enhanced call animation with haptic feedback&#10;            binding.root.performHapticFeedback(HapticFeedbackConstants.CONFIRM)&#10;&#10;            // Check for call permission&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    requireContext(),&#10;                    Manifest.permission.CALL_PHONE&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Direct call&#10;                    val callIntent = Intent(Intent.ACTION_CALL).apply {&#10;                        data = &quot;tel:$phoneNumber&quot;.toUri()&#10;                    }&#10;                    if (callIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                        startActivity(callIntent)&#10;                    } else {&#10;                        // Fallback to dialer if direct call not available&#10;                        makeDialerCall(phoneNumber)&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    makeDialerCall(phoneNumber)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Fallback to dialer on any error&#10;            makeDialerCall(phoneNumber)&#10;        }&#10;    }&#10;&#10;    private fun makeDialerCall(phoneNumber: String) {&#10;        try {&#10;            // Use dialer as safe fallback&#10;            val dialIntent = Intent(Intent.ACTION_DIAL).apply {&#10;                data = &quot;tel:$phoneNumber&quot;.toUri()&#10;            }&#10;            if (dialIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                startActivity(dialIntent)&#10;            } else if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;No dialer app available&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error making call&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun validateContactInput(name: String, phone: String): Boolean {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return false&#10;&#10;        if (name.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a contact name&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        if (phone.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        // Basic phone number validation&#10;        val phoneRegex = &quot;^[+]?[0-9()]{7,15}$&quot;.toRegex()&#10;        if (!phone.matches(phoneRegex)) {&#10;            Snackbar.make(binding.root, &quot;Please enter a valid phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        return true&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;&#10;        _binding = null&#10;    }&#10;&#10;    private fun updateStateButtonText(state: String?) {&#10;        if (_binding == null) return&#10;&#10;        if (state.isNullOrEmpty()) {&#10;            binding.btnSelectState.contentDescription = &quot;Select State&quot;&#10;            // Keep default location icon&#10;        } else {&#10;            binding.btnSelectState.contentDescription = &quot;Current: $state (tap to change)&quot;&#10;            // Could show a different icon or add text overlay&#10;        }&#10;    }&#10;&#10;    private fun showStateSelectionDialog() {&#10;        if (_binding == null || !isAdded) return&#10;        &#10;        try {&#10;            val currentState = viewModel.selectedState.value&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_select_state, null)&#10;            &#10;            val dialog = AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;            &#10;            val btnUseLocation = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnUseLocation)&#10;            val btnManualSelection = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnManualSelection)&#10;            val btnShowAll = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnShowAll)&#10;            &#10;            // Show current state if selected&#10;            if (!currentState.isNullOrEmpty()) {&#10;                val titleText = dialogView.findViewById&lt;android.widget.TextView&gt;(android.R.id.title)&#10;                titleText?.text = &quot;Change State (Current: $currentState)&quot;&#10;            }&#10;&#10;            btnUseLocation.setOnClickListener {&#10;                dialog.dismiss()&#10;                requestLocationAndDetectState()&#10;            }&#10;            &#10;            btnManualSelection.setOnClickListener {&#10;                dialog.dismiss()&#10;                showManualStateSelection()&#10;            }&#10;            &#10;            btnShowAll.setOnClickListener {&#10;                dialog.dismiss()&#10;                viewModel.clearSelectedState()&#10;                Snackbar.make(binding.root, &quot;State cleared - showing all contacts&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;            &#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error showing state selection&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showStateDialogIfNeeded() {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Welcome! Select Your State&quot;)&#10;            .setMessage(&quot;To show relevant emergency contacts for your area, please select your state. This will only be asked once.&quot;)&#10;            .setPositiveButton(&quot;Select State&quot;) { _, _ -&gt;&#10;                showStateSelectionDialog()&#10;             }&#10;             .setNegativeButton(&quot;Use GPS&quot;) { _, _ -&gt;&#10;                 requestLocationAndDetectState()&#10;             }&#10;             .setCancelable(false)&#10;             .show()&#10;    }&#10;&#10;    // ...existing code...&#10;&#10;    private fun showManualStateSelection() {&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val states = com.example.firstaidapp.data.repository.EmergencyContactsData.getStatesList()&#10;            val stateArray = states.toTypedArray()&#10;&#10;            AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;Select Your State&quot;)&#10;                .setItems(stateArray) { dialog, which -&gt;&#10;                    val selectedState = stateArray[which]&#10;                    viewModel.setSelectedState(selectedState)&#10;                    Snackbar.make(binding.root, &quot;Showing contacts for $selectedState&quot;, Snackbar.LENGTH_LONG).show()&#10;                }&#10;                .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt;&#10;                    dialog.dismiss()&#10;                }&#10;                .show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error showing state list&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestLocationAndDetectState() {&#10;        val locationHelper = LocationHelper(requireContext())&#10;        &#10;        if (locationHelper.hasLocationPermission()) {&#10;            detectLocationAndSetState()&#10;        } else {&#10;            requestLocationPermissionLauncher.launch(&#10;                arrayOf(&#10;                    Manifest.permission.ACCESS_FINE_LOCATION,&#10;                    Manifest.permission.ACCESS_COARSE_LOCATION&#10;                )&#10;            )&#10;        }&#10;    }&#10;    &#10;    private fun detectLocationAndSetState() {&#10;        if (_binding == null || !isAdded) return&#10;        &#10;        val locationHelper = LocationHelper(requireContext())&#10;        &#10;        lifecycleScope.launch {&#10;            try {&#10;                Snackbar.make(binding.root, &quot;Detecting your location...&quot;, Snackbar.LENGTH_SHORT).show()&#10;                &#10;                val state = locationHelper.getCurrentState()&#10;                &#10;                if (state != null) {&#10;                    viewModel.setSelectedState(state)&#10;                    Snackbar.make(binding.root, &quot;Location detected: $state&quot;, Snackbar.LENGTH_LONG).show()&#10;                } else {&#10;                    Snackbar.make(binding.root, &quot;Could not detect your location. Please select your state manually.&quot;, Snackbar.LENGTH_LONG).show()&#10;                    // Only show manual selection if GPS actually failed&#10;                    showManualStateSelection()&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                if (_binding != null) {&#10;                    Snackbar.make(binding.root, &quot;Error detecting location. Please select manually.&quot;, Snackbar.LENGTH_LONG).show()&#10;                    showManualStateSelection()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.ui.contacts&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.TextWatcher&#10;import android.view.HapticFeedbackConstants&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AutoCompleteTextView&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.appcompat.app.AlertDialog&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.net.toUri&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.firstaidapp.R&#10;import com.example.firstaidapp.data.models.ContactType&#10;import com.example.firstaidapp.data.models.EmergencyContact&#10;import com.example.firstaidapp.databinding.FragmentContactsBinding&#10;import com.example.firstaidapp.utils.LocationHelper&#10;import com.google.android.material.snackbar.Snackbar&#10;import kotlinx.coroutines.launch&#10;&#10;class ContactsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentContactsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var viewModel: ContactsViewModel&#10;    private lateinit var contactsAdapter: ContactsAdapter&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted, can make direct call&#10;            Snackbar.make(binding.root, &quot;Permission granted! Tap call button again to make direct call&quot;, Snackbar.LENGTH_SHORT).show()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Using dialer instead&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;    &#10;    private val requestLocationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestMultiplePermissions()&#10;    ) { permissions -&gt;&#10;        if (permissions[Manifest.permission.ACCESS_FINE_LOCATION] == true ||&#10;            permissions[Manifest.permission.ACCESS_COARSE_LOCATION] == true) {&#10;            // Permission granted, get location&#10;            detectLocationAndSetState()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Location permission denied. Please select your state manually.&quot;, Snackbar.LENGTH_LONG).show()&#10;            showManualStateSelection()&#10;        }&#10;    }&#10;&#10;    private val requestContactsPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        viewModel.setContactsPermissionGranted(isGranted)&#10;        if (isGranted) {&#10;            Snackbar.make(binding.root, &quot;Permission granted! Loading contacts...&quot;, Snackbar.LENGTH_SHORT).show()&#10;            showPhoneContactPickerDialog()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Permission denied. You can enable it in Settings to import contacts.&quot;, Snackbar.LENGTH_LONG).show()&#10;        }&#10;    }&#10;&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentContactsBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        setupViewModel()&#10;        setupRecyclerView()&#10;        setupObservers()&#10;        setupClickListeners()&#10;        setupSearchFunctionality()&#10;&#10;        // Only show state dialog if no state has been selected before&#10;        if (!viewModel.isStateSelected()) {&#10;            showStateDialogIfNeeded()&#10;        }&#10;    }&#10;&#10;    private fun setupViewModel() {&#10;        val factory = ContactsViewModelFactory(requireActivity().application)&#10;        viewModel = ViewModelProvider(this, factory)[ContactsViewModel::class.java]&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        contactsAdapter = ContactsAdapter { contact -&gt;&#10;            makePhoneCall(contact.phoneNumber)&#10;        }&#10;&#10;        binding.rvContacts.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = contactsAdapter&#10;        }&#10;    }&#10;&#10;    private fun setupObservers() {&#10;        // Observe all contacts (filtered by state)&#10;        viewModel.allContacts.observe(viewLifecycleOwner) { contacts -&gt;&#10;            // Only update if no search is active&#10;            if (binding.etSearchContacts.text.isNullOrEmpty()) {&#10;                contactsAdapter.submitList(contacts)&#10;            }&#10;        }&#10;&#10;        // Observe filtered contacts (for search results)&#10;        viewModel.filteredContacts.observe(viewLifecycleOwner) { filteredContacts -&gt;&#10;            // Only update if search is active and we have filtered results&#10;            if (!binding.etSearchContacts.text.isNullOrEmpty() &amp;&amp; filteredContacts.isNotEmpty()) {&#10;                contactsAdapter.submitList(filteredContacts)&#10;            }&#10;        }&#10;&#10;        // Observe selected state to update button text&#10;        viewModel.selectedState.observe(viewLifecycleOwner) { state -&gt;&#10;            updateStateButtonText(state)&#10;        }&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.btnSettings.setOnClickListener {&#10;            // Use basic navigation instead of SafeArgs for compatibility&#10;            findNavController().navigate(R.id.navigation_settings)&#10;        }&#10;&#10;        binding.fabAddContact.setOnClickListener {&#10;            showAddContactDialog()&#10;        }&#10;        &#10;        binding.btnSelectState.setOnClickListener {&#10;            showStateSelectionDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupSearchFunctionality() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return&#10;&#10;        binding.etSearchContacts.addTextChangedListener(object : TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                // Add null check&#10;                if (_binding == null) return&#10;&#10;                val query = s.toString()&#10;&#10;                // Removed all animations - immediate search instead&#10;                if (query.isNotEmpty()) {&#10;                    try {&#10;                        viewModel.searchContacts(query)&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                } else {&#10;                    try {&#10;                        viewModel.clearSearch()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;            }&#10;&#10;            override fun afterTextChanged(s: Editable?) {}&#10;        })&#10;&#10;        // Removed focus animations - basic functionality only&#10;        binding.etSearchContacts.setOnFocusChangeListener { view, hasFocus -&gt;&#10;            if (_binding == null) return@setOnFocusChangeListener&#10;            // No animations - just basic elevation change&#10;            if (hasFocus) {&#10;                view.elevation = 8f&#10;            } else {&#10;                view.elevation = 2f&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showAddContactDialog() {&#10;        // Use the new method with empty prefill data&#10;        showAddContactDialogWithData(&quot;&quot;, &quot;&quot;)&#10;    }&#10;&#10;    private fun showAddContactDialogOld() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_add_contact, null)&#10;&#10;            val dialog = AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;&#10;            // Get dialog views&#10;            val etContactName = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etContactName)&#10;            val etPhoneNumber = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etPhoneNumber)&#10;            val etRelationship = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etRelationship)&#10;            val spinnerContactType = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.spinnerContactType)&#10;            val etNotes = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etNotes)&#10;            val btnImportFromPhone = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnImportFromPhone)&#10;            val btnCancel = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnCancel)&#10;            val btnSave = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnSave)&#10;&#10;            // Null checks for all views&#10;            if (etContactName == null || etPhoneNumber == null || spinnerContactType == null ||&#10;                btnImportFromPhone == null || btnCancel == null || btnSave == null) {&#10;                return&#10;            }&#10;&#10;            // Setup contact type dropdown&#10;            setupContactTypeDropdown(spinnerContactType)&#10;&#10;            // Setup click listeners with null checks&#10;            btnImportFromPhone.setOnClickListener {&#10;                dialog.dismiss()&#10;                if (isAdded &amp;&amp; _binding != null) {&#10;                    openPhoneContactsSelection()&#10;                }&#10;            }&#10;&#10;            btnCancel.setOnClickListener {&#10;                dialog.dismiss()&#10;            }&#10;&#10;            btnSave.setOnClickListener {&#10;                if (!isAdded || _binding == null) {&#10;                    dialog.dismiss()&#10;                    return@setOnClickListener&#10;                }&#10;&#10;                val name = etContactName.text?.toString()?.trim() ?: &quot;&quot;&#10;                val phone = etPhoneNumber.text?.toString()?.trim() ?: &quot;&quot;&#10;                val relationship = etRelationship.text?.toString()?.trim() ?: &quot;&quot;&#10;                val typeString = spinnerContactType.text?.toString() ?: &quot;Personal&quot;&#10;                val notes = etNotes.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;                if (validateContactInput(name, phone)) {&#10;                    val contactType = when (typeString) {&#10;                        &quot;Emergency Service&quot; -&gt; ContactType.EMERGENCY_SERVICE&#10;                        &quot;Poison Control&quot; -&gt; ContactType.POISON_CONTROL&#10;                        &quot;Hospital&quot; -&gt; ContactType.HOSPITAL&#10;                        &quot;Police&quot; -&gt; ContactType.POLICE&#10;                        &quot;Fire Department&quot; -&gt; ContactType.FIRE_DEPARTMENT&#10;                        &quot;Family&quot; -&gt; ContactType.FAMILY&#10;                        &quot;Doctor&quot; -&gt; ContactType.DOCTOR&#10;                        &quot;Veterinarian&quot; -&gt; ContactType.VETERINARIAN&#10;                        &quot;Other&quot; -&gt; ContactType.OTHER&#10;                        else -&gt; ContactType.PERSONAL&#10;                    }&#10;&#10;                    val contact = EmergencyContact(&#10;                        name = name,&#10;                        phoneNumber = phone,&#10;                        relationship = relationship,&#10;                        type = contactType,&#10;                        notes = notes,&#10;                        // Assign currently selected state for manual contacts&#10;                        state = viewModel.selectedState.value ?: &quot;National&quot;&#10;                    )&#10;&#10;                    try {&#10;                        viewModel.addContact(contact)&#10;&#10;                        // Removed animation - show immediate success message&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Contact added successfully!&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;&#10;                        dialog.dismiss()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Error adding contact: ${e.message}&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error opening add contact dialog&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupContactTypeDropdown(spinner: AutoCompleteTextView) {&#10;        val contactTypes = arrayOf(&#10;            &quot;Personal&quot;,&#10;            &quot;Family&quot;,&#10;            &quot;Emergency Service&quot;,&#10;            &quot;Hospital&quot;,&#10;            &quot;Police&quot;,&#10;            &quot;Fire Department&quot;,&#10;            &quot;Poison Control&quot;,&#10;            &quot;Doctor&quot;,&#10;            &quot;Veterinarian&quot;,&#10;            &quot;Other&quot;&#10;        )&#10;&#10;        val adapter = android.widget.ArrayAdapter(&#10;            requireContext(),&#10;            android.R.layout.simple_dropdown_item_1line,&#10;            contactTypes&#10;        )&#10;&#10;        spinner.setAdapter(adapter)&#10;        spinner.setText(&quot;Personal&quot;, false)&#10;    }&#10;&#10;    private fun openPhoneContactsSelection() {&#10;        // Add safety checks to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // Check if permission is already granted (from SharedPreferences)&#10;            if (viewModel.isContactsPermissionGranted()) {&#10;                // Check runtime permission as well&#10;                if (ContextCompat.checkSelfPermission(&#10;                        requireContext(),&#10;                        Manifest.permission.READ_CONTACTS&#10;                    ) == PackageManager.PERMISSION_GRANTED&#10;                ) {&#10;                    // Permission granted, show contact picker&#10;                    showPhoneContactPickerDialog()&#10;                } else {&#10;                    // Permission was revoked in system settings&#10;                    viewModel.setContactsPermissionGranted(false)&#10;                    requestContactsPermission()&#10;                }&#10;            } else if (viewModel.hasAskedContactsPermission()) {&#10;                // Previously denied, show message to enable in settings&#10;                showContactsPermissionDeniedDialog()&#10;            } else {&#10;                // First time asking&#10;                requestContactsPermission()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error accessing phone contacts&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestContactsPermission() {&#10;        if (_binding == null || !isAdded) return&#10;&#10;        when {&#10;            ContextCompat.checkSelfPermission(&#10;                requireContext(),&#10;                Manifest.permission.READ_CONTACTS&#10;            ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                // Already granted&#10;                viewModel.setContactsPermissionGranted(true)&#10;                showPhoneContactPickerDialog()&#10;            }&#10;            shouldShowRequestPermissionRationale(Manifest.permission.READ_CONTACTS) -&gt; {&#10;                // Show rationale&#10;                AlertDialog.Builder(requireContext())&#10;                    .setTitle(&quot;Contacts Permission Needed&quot;)&#10;                    .setMessage(getString(R.string.contacts_permission_rationale))&#10;                    .setPositiveButton(&quot;Grant Permission&quot;) { _, _ -&gt;&#10;                        requestContactsPermissionLauncher.launch(Manifest.permission.READ_CONTACTS)&#10;                    }&#10;                    .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt;&#10;                        dialog.dismiss()&#10;                        viewModel.setContactsPermissionAsked(true)&#10;                    }&#10;                    .show()&#10;            }&#10;            else -&gt; {&#10;                // Request permission&#10;                requestContactsPermissionLauncher.launch(Manifest.permission.READ_CONTACTS)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showContactsPermissionDeniedDialog() {&#10;        if (_binding == null || !isAdded) return&#10;&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Contacts Permission Required&quot;)&#10;            .setMessage(getString(R.string.contacts_permission_permanently_denied))&#10;            .setPositiveButton(&quot;Open Settings&quot;) { _, _ -&gt;&#10;                try {&#10;                    val intent = Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS)&#10;                    intent.data = &quot;package:${requireContext().packageName}&quot;.toUri()&#10;                    startActivity(intent)&#10;                } catch (e: Exception) {&#10;                    e.printStackTrace()&#10;                }&#10;            }&#10;            .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt;&#10;                dialog.dismiss()&#10;            }&#10;            .show()&#10;    }&#10;&#10;    private fun showPhoneContactPickerDialog() {&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_phone_contacts_picker, null)&#10;&#10;            val dialog = AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;&#10;            val rvPhoneContacts = dialogView.findViewById&lt;androidx.recyclerview.widget.RecyclerView&gt;(R.id.rvPhoneContacts)&#10;            val etSearch = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etSearchPhoneContacts)&#10;            val btnCancel = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnCancelPicker)&#10;            val progressBar = dialogView.findViewById&lt;android.widget.ProgressBar&gt;(R.id.progressBar)&#10;            val emptyState = dialogView.findViewById&lt;android.view.ViewGroup&gt;(R.id.layoutEmptyState)&#10;&#10;            if (rvPhoneContacts == null || etSearch == null || btnCancel == null || &#10;                progressBar == null || emptyState == null) {&#10;                return&#10;            }&#10;&#10;            // Show loading&#10;            progressBar.visibility = View.VISIBLE&#10;            rvPhoneContacts.visibility = View.GONE&#10;&#10;            val phoneContactsAdapter = PhoneContactsAdapter { contact -&gt;&#10;                // Contact selected - fill the add contact dialog&#10;                dialog.dismiss()&#10;                prefillContactData(contact)&#10;            }&#10;&#10;            rvPhoneContacts.layoutManager = LinearLayoutManager(requireContext())&#10;            rvPhoneContacts.adapter = phoneContactsAdapter&#10;&#10;            // Load contacts in background&#10;            lifecycleScope.launch {&#10;                try {&#10;                    val contacts = com.example.firstaidapp.utils.ContactsHelper.getPhoneContacts(requireContext())&#10;                    &#10;                    progressBar.visibility = View.GONE&#10;                    &#10;                    if (contacts.isEmpty()) {&#10;                        emptyState.visibility = View.VISIBLE&#10;                        rvPhoneContacts.visibility = View.GONE&#10;                    } else {&#10;                        rvPhoneContacts.visibility = View.VISIBLE&#10;                        emptyState.visibility = View.GONE&#10;                        phoneContactsAdapter.submitList(contacts)&#10;&#10;                        // Setup search&#10;                        etSearch.addTextChangedListener(object : TextWatcher {&#10;                            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;                            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                                val query = s.toString()&#10;                                val filtered = com.example.firstaidapp.utils.ContactsHelper.searchContacts(contacts, query)&#10;                                phoneContactsAdapter.submitList(filtered)&#10;                            }&#10;                            override fun afterTextChanged(s: Editable?) {}&#10;                        })&#10;                    }&#10;                } catch (e: Exception) {&#10;                    e.printStackTrace()&#10;                    progressBar.visibility = View.GONE&#10;                    emptyState.visibility = View.VISIBLE&#10;                    if (_binding != null) {&#10;                        Snackbar.make(binding.root, &quot;Error loading contacts&quot;, Snackbar.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;&#10;            btnCancel.setOnClickListener {&#10;                dialog.dismiss()&#10;            }&#10;&#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error opening contact picker&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun prefillContactData(contact: com.example.firstaidapp.data.models.PhoneContact) {&#10;        if (_binding == null || !isAdded) return&#10;&#10;        // Show the add contact dialog with pre-filled data&#10;        showAddContactDialogWithData(contact.name, contact.phoneNumber)&#10;    }&#10;&#10;    private fun showAddContactDialogWithData(prefillName: String = &quot;&quot;, prefillPhone: String = &quot;&quot;) {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_add_contact, null)&#10;&#10;            val dialog = AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;&#10;            // Get dialog views&#10;            val etContactName = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etContactName)&#10;            val etPhoneNumber = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etPhoneNumber)&#10;            val etRelationship = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etRelationship)&#10;            val spinnerContactType = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.spinnerContactType)&#10;            val etNotes = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etNotes)&#10;            val btnImportFromPhone = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnImportFromPhone)&#10;            val btnCancel = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnCancel)&#10;            val btnSave = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnSave)&#10;&#10;            // Null checks for all views&#10;            if (etContactName == null || etPhoneNumber == null || spinnerContactType == null ||&#10;                btnImportFromPhone == null || btnCancel == null || btnSave == null) {&#10;                return&#10;            }&#10;&#10;            // Prefill data if provided&#10;            etContactName.setText(prefillName)&#10;            etPhoneNumber.setText(prefillPhone)&#10;&#10;            // Setup contact type dropdown&#10;            setupContactTypeDropdown(spinnerContactType)&#10;&#10;            // Hide import button if already importing&#10;            if (prefillName.isNotEmpty()) {&#10;                btnImportFromPhone.visibility = View.GONE&#10;            }&#10;&#10;            // Setup click listeners with null checks&#10;            btnImportFromPhone.setOnClickListener {&#10;                dialog.dismiss()&#10;                if (isAdded &amp;&amp; _binding != null) {&#10;                    openPhoneContactsSelection()&#10;                }&#10;            }&#10;&#10;            btnCancel.setOnClickListener {&#10;                dialog.dismiss()&#10;            }&#10;&#10;            btnSave.setOnClickListener {&#10;                if (!isAdded || _binding == null) {&#10;                    dialog.dismiss()&#10;                    return@setOnClickListener&#10;                }&#10;&#10;                val name = etContactName.text?.toString()?.trim() ?: &quot;&quot;&#10;                val phone = etPhoneNumber.text?.toString()?.trim() ?: &quot;&quot;&#10;                val relationship = etRelationship.text?.toString()?.trim() ?: &quot;&quot;&#10;                val typeString = spinnerContactType.text?.toString() ?: &quot;Personal&quot;&#10;                val notes = etNotes.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;                if (validateContactInput(name, phone)) {&#10;                    val contactType = when (typeString) {&#10;                        &quot;Emergency Service&quot; -&gt; ContactType.EMERGENCY_SERVICE&#10;                        &quot;Poison Control&quot; -&gt; ContactType.POISON_CONTROL&#10;                        &quot;Hospital&quot; -&gt; ContactType.HOSPITAL&#10;                        &quot;Police&quot; -&gt; ContactType.POLICE&#10;                        &quot;Fire Department&quot; -&gt; ContactType.FIRE_DEPARTMENT&#10;                        &quot;Family&quot; -&gt; ContactType.FAMILY&#10;                        &quot;Doctor&quot; -&gt; ContactType.DOCTOR&#10;                        &quot;Veterinarian&quot; -&gt; ContactType.VETERINARIAN&#10;                        &quot;Other&quot; -&gt; ContactType.OTHER&#10;                        else -&gt; ContactType.PERSONAL&#10;                    }&#10;&#10;                    val contact = EmergencyContact(&#10;                        name = name,&#10;                        phoneNumber = phone,&#10;                        relationship = relationship,&#10;                        type = contactType,&#10;                        notes = notes,&#10;                        state = viewModel.selectedState.value ?: &quot;National&quot;&#10;                    )&#10;&#10;                    try {&#10;                        viewModel.addContact(contact)&#10;&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Contact added successfully!&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;&#10;                        dialog.dismiss()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Error adding contact: ${e.message}&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error opening add contact dialog&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun makePhoneCall(phoneNumber: String) {&#10;        // Add comprehensive null checks and error handling&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // Enhanced call animation with haptic feedback&#10;            binding.root.performHapticFeedback(HapticFeedbackConstants.CONFIRM)&#10;&#10;            // Check for call permission&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    requireContext(),&#10;                    Manifest.permission.CALL_PHONE&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Direct call&#10;                    val callIntent = Intent(Intent.ACTION_CALL).apply {&#10;                        data = &quot;tel:$phoneNumber&quot;.toUri()&#10;                    }&#10;                    if (callIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                        startActivity(callIntent)&#10;                    } else {&#10;                        // Fallback to dialer if direct call not available&#10;                        makeDialerCall(phoneNumber)&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    makeDialerCall(phoneNumber)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Fallback to dialer on any error&#10;            makeDialerCall(phoneNumber)&#10;        }&#10;    }&#10;&#10;    private fun makeDialerCall(phoneNumber: String) {&#10;        try {&#10;            // Use dialer as safe fallback&#10;            val dialIntent = Intent(Intent.ACTION_DIAL).apply {&#10;                data = &quot;tel:$phoneNumber&quot;.toUri()&#10;            }&#10;            if (dialIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                startActivity(dialIntent)&#10;            } else if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;No dialer app available&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error making call&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun validateContactInput(name: String, phone: String): Boolean {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return false&#10;&#10;        if (name.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a contact name&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        if (phone.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        // Basic phone number validation&#10;        val phoneRegex = &quot;^[+]?[0-9()]{7,15}$&quot;.toRegex()&#10;        if (!phone.matches(phoneRegex)) {&#10;            Snackbar.make(binding.root, &quot;Please enter a valid phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        return true&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;&#10;        _binding = null&#10;    }&#10;&#10;    private fun updateStateButtonText(state: String?) {&#10;        if (_binding == null) return&#10;&#10;        if (state.isNullOrEmpty()) {&#10;            binding.btnSelectState.contentDescription = &quot;Select State&quot;&#10;            // Keep default location icon&#10;        } else {&#10;            binding.btnSelectState.contentDescription = &quot;Current: $state (tap to change)&quot;&#10;            // Could show a different icon or add text overlay&#10;        }&#10;    }&#10;&#10;    private fun showStateSelectionDialog() {&#10;        if (_binding == null || !isAdded) return&#10;        &#10;        try {&#10;            val currentState = viewModel.selectedState.value&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_select_state, null)&#10;            &#10;            val dialog = AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;            &#10;            val btnUseLocation = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnUseLocation)&#10;            val btnManualSelection = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnManualSelection)&#10;            val btnShowAll = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnShowAll)&#10;            &#10;            // Show current state if selected&#10;            if (!currentState.isNullOrEmpty()) {&#10;                val titleText = dialogView.findViewById&lt;android.widget.TextView&gt;(android.R.id.title)&#10;                titleText?.text = &quot;Change State (Current: $currentState)&quot;&#10;            }&#10;&#10;            btnUseLocation.setOnClickListener {&#10;                dialog.dismiss()&#10;                requestLocationAndDetectState()&#10;            }&#10;            &#10;            btnManualSelection.setOnClickListener {&#10;                dialog.dismiss()&#10;                showManualStateSelection()&#10;            }&#10;            &#10;            btnShowAll.setOnClickListener {&#10;                dialog.dismiss()&#10;                viewModel.clearSelectedState()&#10;                Snackbar.make(binding.root, &quot;State cleared - showing all contacts&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;            &#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error showing state selection&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showStateDialogIfNeeded() {&#10;        AlertDialog.Builder(requireContext())&#10;            .setTitle(&quot;Welcome! Select Your State&quot;)&#10;            .setMessage(&quot;To show relevant emergency contacts for your area, please select your state. This will only be asked once.&quot;)&#10;            .setPositiveButton(&quot;Select State&quot;) { _, _ -&gt;&#10;                showStateSelectionDialog()&#10;             }&#10;             .setNegativeButton(&quot;Use GPS&quot;) { _, _ -&gt;&#10;                 requestLocationAndDetectState()&#10;             }&#10;             .setCancelable(false)&#10;             .show()&#10;    }&#10;&#10;    // ...existing code...&#10;&#10;    private fun showManualStateSelection() {&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val states = com.example.firstaidapp.data.repository.EmergencyContactsData.getStatesList()&#10;            val stateArray = states.toTypedArray()&#10;&#10;            AlertDialog.Builder(requireContext())&#10;                .setTitle(&quot;Select Your State&quot;)&#10;                .setItems(stateArray) { dialog, which -&gt;&#10;                    val selectedState = stateArray[which]&#10;                    viewModel.setSelectedState(selectedState)&#10;                    Snackbar.make(binding.root, &quot;Showing contacts for $selectedState&quot;, Snackbar.LENGTH_LONG).show()&#10;                }&#10;                .setNegativeButton(&quot;Cancel&quot;) { dialog, _ -&gt;&#10;                    dialog.dismiss()&#10;                }&#10;                .show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error showing state list&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun requestLocationAndDetectState() {&#10;        val locationHelper = LocationHelper(requireContext())&#10;        &#10;        if (locationHelper.hasLocationPermission()) {&#10;            detectLocationAndSetState()&#10;        } else {&#10;            requestLocationPermissionLauncher.launch(&#10;                arrayOf(&#10;                    Manifest.permission.ACCESS_FINE_LOCATION,&#10;                    Manifest.permission.ACCESS_COARSE_LOCATION&#10;                )&#10;            )&#10;        }&#10;    }&#10;    &#10;    private fun detectLocationAndSetState() {&#10;        if (_binding == null || !isAdded) return&#10;        &#10;        val locationHelper = LocationHelper(requireContext())&#10;        &#10;        lifecycleScope.launch {&#10;            try {&#10;                Snackbar.make(binding.root, &quot;Detecting your location...&quot;, Snackbar.LENGTH_SHORT).show()&#10;                &#10;                val state = locationHelper.getCurrentState()&#10;                &#10;                if (state != null) {&#10;                    viewModel.setSelectedState(state)&#10;                    Snackbar.make(binding.root, &quot;Location detected: $state&quot;, Snackbar.LENGTH_LONG).show()&#10;                } else {&#10;                    Snackbar.make(binding.root, &quot;Could not detect your location. Please select your state manually.&quot;, Snackbar.LENGTH_LONG).show()&#10;                    // Only show manual selection if GPS actually failed&#10;                    showManualStateSelection()&#10;                }&#10;            } catch (e: Exception) {&#10;                e.printStackTrace()&#10;                if (_binding != null) {&#10;                    Snackbar.make(binding.root, &quot;Error detecting location. Please select manually.&quot;, Snackbar.LENGTH_LONG).show()&#10;                    showManualStateSelection()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/ContactsViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/ContactsViewModel.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.contacts&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.asLiveData&#10;import androidx.lifecycle.switchMap&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.firstaidapp.data.database.AppDatabase&#10;import com.example.firstaidapp.data.models.ContactType&#10;import com.example.firstaidapp.data.models.EmergencyContact&#10;import com.example.firstaidapp.data.repository.EmergencyContactsData&#10;import com.example.firstaidapp.utils.UserPreferencesManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;&#10;class ContactsViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val database = AppDatabase.getDatabase(application)&#10;    private val contactDao = database.contactDao()&#10;    private val prefsManager = UserPreferencesManager(application)&#10;&#10;    // Current selected state for filtering - load from SharedPreferences&#10;    private val _selectedState = MutableLiveData(prefsManager.selectedState)&#10;    val selectedState: LiveData&lt;String&gt; = _selectedState&#10;&#10;    // Search query for filtering contacts&#10;    private val _searchQuery = MutableLiveData(&quot;&quot;)&#10;    val searchQuery: LiveData&lt;String&gt; = _searchQuery&#10;&#10;    // Loading state&#10;    private val _isLoading = MutableLiveData(false)&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    // Error message&#10;    private val _errorMessage = MutableLiveData&lt;String?&gt;()&#10;    val errorMessage: LiveData&lt;String?&gt; = _errorMessage&#10;&#10;    // Available states for dropdown&#10;    private val _availableStates = MutableLiveData&lt;List&lt;String&gt;&gt;()&#10;    val availableStates: LiveData&lt;List&lt;String&gt;&gt; = _availableStates&#10;&#10;    // All contacts based on selected state&#10;    val allContacts: LiveData&lt;List&lt;EmergencyContact&gt;&gt; =&#10;        selectedState.switchMap { state -&gt;&#10;            if (state == &quot;National&quot;) {&#10;                contactDao.getAllContacts()&#10;            } else {&#10;                contactDao.getContactsByStateWithNational(state)&#10;            }.asLiveData()&#10;        }&#10;&#10;    // Filtered contacts based on search query&#10;    val filteredContacts: LiveData&lt;List&lt;EmergencyContact&gt;&gt; =&#10;        searchQuery.switchMap { query -&gt;&#10;            if (query.isBlank()) {&#10;                // Return empty list when query is blank, as allContacts is used for non-search&#10;                MutableLiveData(emptyList())&#10;            } else {&#10;                contactDao.searchContacts(query).asLiveData()&#10;            }&#10;        }&#10;&#10;    init {&#10;        loadAvailableStates()&#10;    }&#10;&#10;    fun isStateSelected(): Boolean {&#10;        return prefsManager.isStateSelectionDone&#10;    }&#10;&#10;    fun setSelectedState(state: String) {&#10;        _selectedState.value = state&#10;        // Persist to SharedPreferences&#10;        prefsManager.selectedState = state&#10;        prefsManager.isStateSelectionDone = true&#10;    }&#10;    &#10;    fun clearSelectedState() {&#10;        _selectedState.value = &quot;National&quot;&#10;        // Persist to SharedPreferences&#10;        prefsManager.selectedState = &quot;National&quot;&#10;        prefsManager.isStateSelectionDone = false&#10;    }&#10;&#10;    fun searchContacts(query: String) {&#10;        _searchQuery.value = query&#10;    }&#10;&#10;    fun clearSearch() {&#10;        _searchQuery.value = &quot;&quot;&#10;    }&#10;&#10;    fun addContact(contact: EmergencyContact) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                contactDao.insertContact(contact)&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to add contact: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateContact(contact: EmergencyContact) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                contactDao.updateContact(contact)&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to update contact: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteContact(contact: EmergencyContact) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                if (contact.isDefault) {&#10;                    // Soft delete for default contacts&#10;                    contactDao.softDeleteContact(contact.id)&#10;                } else {&#10;                    // Hard delete for user-added contacts&#10;                    contactDao.deleteContact(contact)&#10;                }&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to delete contact: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getContactsByType(type: ContactType): LiveData&lt;List&lt;EmergencyContact&gt;&gt; {&#10;        return contactDao.getContactsByType(type).asLiveData()&#10;    }&#10;&#10;    fun refreshContacts() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                loadAvailableStates()&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to refresh contacts: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadAvailableStates() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val states = contactDao.getAvailableStates().toMutableList()&#10;                // Ensure &quot;National&quot; is always first in the list&#10;                states.remove(&quot;National&quot;)&#10;                states.add(0, &quot;National&quot;)&#10;                _availableStates.value = states&#10;            } catch (e: Exception) {&#10;                // Fallback to predefined states if database query fails&#10;                val fallbackStates = mutableListOf(&quot;National&quot;)&#10;                fallbackStates.addAll(EmergencyContactsData.getStatesList())&#10;                _availableStates.value = fallbackStates&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.ui.contacts&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.asLiveData&#10;import androidx.lifecycle.switchMap&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.firstaidapp.data.database.AppDatabase&#10;import com.example.firstaidapp.data.models.ContactType&#10;import com.example.firstaidapp.data.models.EmergencyContact&#10;import com.example.firstaidapp.data.repository.EmergencyContactsData&#10;import com.example.firstaidapp.utils.UserPreferencesManager&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.launch&#10;&#10;class ContactsViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private val database = AppDatabase.getDatabase(application)&#10;    private val contactDao = database.contactDao()&#10;    private val prefsManager = UserPreferencesManager(application)&#10;&#10;    // Current selected state for filtering - load from SharedPreferences&#10;    private val _selectedState = MutableLiveData(prefsManager.selectedState)&#10;    val selectedState: LiveData&lt;String&gt; = _selectedState&#10;&#10;    // Search query for filtering contacts&#10;    private val _searchQuery = MutableLiveData(&quot;&quot;)&#10;    val searchQuery: LiveData&lt;String&gt; = _searchQuery&#10;&#10;    // Loading state&#10;    private val _isLoading = MutableLiveData(false)&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    // Error message&#10;    private val _errorMessage = MutableLiveData&lt;String?&gt;()&#10;    val errorMessage: LiveData&lt;String?&gt; = _errorMessage&#10;&#10;    // Available states for dropdown&#10;    private val _availableStates = MutableLiveData&lt;List&lt;String&gt;&gt;()&#10;    val availableStates: LiveData&lt;List&lt;String&gt;&gt; = _availableStates&#10;&#10;    // All contacts based on selected state&#10;    val allContacts: LiveData&lt;List&lt;EmergencyContact&gt;&gt; =&#10;        selectedState.switchMap { state -&gt;&#10;            if (state == &quot;National&quot;) {&#10;                contactDao.getAllContacts()&#10;            } else {&#10;                contactDao.getContactsByStateWithNational(state)&#10;            }.asLiveData()&#10;        }&#10;&#10;    // Filtered contacts based on search query&#10;    val filteredContacts: LiveData&lt;List&lt;EmergencyContact&gt;&gt; =&#10;        searchQuery.switchMap { query -&gt;&#10;            if (query.isBlank()) {&#10;                // Return empty list when query is blank, as allContacts is used for non-search&#10;                MutableLiveData(emptyList())&#10;            } else {&#10;                contactDao.searchContacts(query).asLiveData()&#10;            }&#10;        }&#10;&#10;    init {&#10;        loadAvailableStates()&#10;    }&#10;&#10;    fun isStateSelected(): Boolean {&#10;        return prefsManager.isStateSelectionDone&#10;    }&#10;&#10;    fun setSelectedState(state: String) {&#10;        _selectedState.value = state&#10;        // Persist to SharedPreferences&#10;        prefsManager.selectedState = state&#10;        prefsManager.isStateSelectionDone = true&#10;    }&#10;    &#10;    fun clearSelectedState() {&#10;        _selectedState.value = &quot;National&quot;&#10;        // Persist to SharedPreferences&#10;        prefsManager.selectedState = &quot;National&quot;&#10;        prefsManager.isStateSelectionDone = false&#10;    }&#10;&#10;    fun searchContacts(query: String) {&#10;        _searchQuery.value = query&#10;    }&#10;&#10;    fun clearSearch() {&#10;        _searchQuery.value = &quot;&quot;&#10;    }&#10;&#10;    fun addContact(contact: EmergencyContact) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                contactDao.insertContact(contact)&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to add contact: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun updateContact(contact: EmergencyContact) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                contactDao.updateContact(contact)&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to update contact: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun deleteContact(contact: EmergencyContact) {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                if (contact.isDefault) {&#10;                    // Soft delete for default contacts&#10;                    contactDao.softDeleteContact(contact.id)&#10;                } else {&#10;                    // Hard delete for user-added contacts&#10;                    contactDao.deleteContact(contact)&#10;                }&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to delete contact: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getContactsByType(type: ContactType): LiveData&lt;List&lt;EmergencyContact&gt;&gt; {&#10;        return contactDao.getContactsByType(type).asLiveData()&#10;    }&#10;&#10;    fun refreshContacts() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _isLoading.value = true&#10;                loadAvailableStates()&#10;                _errorMessage.value = null&#10;            } catch (e: Exception) {&#10;                _errorMessage.value = &quot;Failed to refresh contacts: ${e.message}&quot;&#10;            } finally {&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadAvailableStates() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val states = contactDao.getAvailableStates().toMutableList()&#10;                // Ensure &quot;National&quot; is always first in the list&#10;                states.remove(&quot;National&quot;)&#10;                states.add(0, &quot;National&quot;)&#10;                _availableStates.value = states&#10;            } catch (e: Exception) {&#10;                // Fallback to predefined states if database query fails&#10;                val fallbackStates = mutableListOf(&quot;National&quot;)&#10;                fallbackStates.addAll(EmergencyContactsData.getStatesList())&#10;                _availableStates.value = fallbackStates&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _errorMessage.value = null&#10;    }&#10;&#10;    // Contacts Permission Management&#10;    fun hasAskedContactsPermission(): Boolean {&#10;        return prefsManager.hasAskedContactsPermission&#10;    }&#10;&#10;    fun setContactsPermissionAsked(asked: Boolean) {&#10;        prefsManager.hasAskedContactsPermission = asked&#10;    }&#10;&#10;    fun isContactsPermissionGranted(): Boolean {&#10;        return prefsManager.contactsPermissionGranted&#10;    }&#10;&#10;    fun setContactsPermissionGranted(granted: Boolean) {&#10;        prefsManager.contactsPermissionGranted = granted&#10;        prefsManager.hasAskedContactsPermission = true&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/PhoneContactsAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/PhoneContactsAdapter.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.ui.contacts&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.firstaidapp.data.models.PhoneContact&#10;&#10;class PhoneContactsAdapter(&#10;    private val onContactClick: (PhoneContact) -&gt; Unit&#10;) : ListAdapter&lt;PhoneContact, PhoneContactsAdapter.PhoneContactViewHolder&gt;(PhoneContactDiffCallback()) {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PhoneContactViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(android.R.layout.simple_list_item_2, parent, false)&#10;        return PhoneContactViewHolder(view, onContactClick)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: PhoneContactViewHolder, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    class PhoneContactViewHolder(&#10;        itemView: View,&#10;        private val onContactClick: (PhoneContact) -&gt; Unit&#10;    ) : RecyclerView.ViewHolder(itemView) {&#10;&#10;        private val text1: TextView = itemView.findViewById(android.R.id.text1)&#10;        private val text2: TextView = itemView.findViewById(android.R.id.text2)&#10;&#10;        fun bind(contact: PhoneContact) {&#10;            text1.text = contact.name&#10;            text2.text = contact.phoneNumber&#10;            &#10;            itemView.setOnClickListener {&#10;                onContactClick(contact)&#10;            }&#10;        }&#10;    }&#10;&#10;    private class PhoneContactDiffCallback : DiffUtil.ItemCallback&lt;PhoneContact&gt;() {&#10;        override fun areItemsTheSame(oldItem: PhoneContact, newItem: PhoneContact): Boolean {&#10;            return oldItem.id == newItem.id&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: PhoneContact, newItem: PhoneContact): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/home/VideoMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/home/VideoMapper.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.home&#10;&#10;/**&#10; * Maps first aid guide titles to their corresponding MP4 video files&#10; * This provides real video demonstrations for better understanding&#10; */&#10;object VideoMapper {&#10;&#10;    private val videoMap = mapOf(&#10;        // Life-Threatening Emergencies - Critical procedure videos&#10;        &quot;CPR&quot; to &quot;videos/cpr_demonstration.mp4&quot;,&#10;        &quot;Choking&quot; to &quot;videos/choking_heimlich.mp4&quot;,&#10;        &quot;Heart Attack&quot; to &quot;videos/heart_attack_response.mp4&quot;,&#10;        &quot;Stroke&quot; to &quot;videos/stroke_fast_assessment.mp4&quot;,&#10;        &quot;Drowning&quot; to &quot;videos/drowning_rescue.mp4&quot;,&#10;&#10;        // Trauma &amp; Injuries - Medical procedure videos&#10;        &quot;Severe Bleeding&quot; to &quot;videos/bleeding_control.mp4&quot;,&#10;        &quot;Burns&quot; to &quot;videos/burns_treatment.mp4&quot;,&#10;        &quot;Fractures&quot; to &quot;videos/fracture_immobilization.mp4&quot;,&#10;        &quot;Sprains and Strains&quot; to &quot;videos/sprain_care.mp4&quot;,&#10;        &quot;Eye Injuries&quot; to &quot;videos/eye_injury_care.mp4&quot;,&#10;        &quot;Nosebleeds&quot; to &quot;videos/nosebleed_control.mp4&quot;,&#10;&#10;        // Medical Conditions - Emergency response videos&#10;        &quot;Allergic Reactions&quot; to &quot;videos/anaphylaxis_epipen.mp4&quot;,&#10;        &quot;Asthma Attack&quot; to &quot;videos/asthma_inhaler.mp4&quot;,&#10;        &quot;Diabetic Emergencies&quot; to &quot;videos/diabetes_response.mp4&quot;,&#10;        &quot;Seizures&quot; to &quot;videos/seizure_response.mp4&quot;,&#10;        &quot;Poisoning&quot; to &quot;videos/poisoning_response.mp4&quot;,&#10;        &quot;Shock&quot; to &quot;videos/shock_treatment.mp4&quot;,&#10;&#10;        // Environmental Emergencies - Hazard response videos&#10;        &quot;Hypothermia&quot; to &quot;videos/hypothermia_warming.mp4&quot;,&#10;        &quot;Heat Exhaustion&quot; to &quot;videos/heat_exhaustion_cooling.mp4&quot;,&#10;        &quot;Bites and Stings&quot; to &quot;videos/bites_stings_treatment.mp4&quot;&#10;    )&#10;&#10;    /**&#10;     * Get the appropriate video for a first aid guide&#10;     * Falls back to a generic instructional video if specific video not found&#10;     */&#10;    fun getVideoForGuide(guideTitle: String): String? {&#10;        // Try exact match first&#10;        videoMap[guideTitle]?.let { return it }&#10;&#10;        // Try partial matching for guides with complex names&#10;        videoMap.forEach { (key, video) -&gt;&#10;            if (guideTitle.contains(key, ignoreCase = true)) {&#10;                return video&#10;            }&#10;        }&#10;&#10;        // Default fallback video&#10;        return &quot;videos/general_first_aid.mp4&quot;&#10;    }&#10;&#10;    /**&#10;     * Check if video file exists (for fallback purposes)&#10;     */&#10;    fun hasVideo(videoPath: String?): Boolean {&#10;        return !videoPath.isNullOrBlank()&#10;    }&#10;&#10;    /**&#10;     * Get all available video paths for preloading&#10;     */&#10;    fun getAllVideoPaths(): List&lt;String&gt; {&#10;        return videoMap.values.toList()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// This file has been replaced by PhotoMapper.kt&#10;// All video functionality has been removed and replaced with photo support" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/utils/ContactsHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/utils/ContactsHelper.kt" />
              <option name="updatedContent" value="package com.example.firstaidapp.utils&#10;&#10;import android.content.Context&#10;import android.provider.ContactsContract&#10;import com.example.firstaidapp.data.models.PhoneContact&#10;&#10;object ContactsHelper {&#10;&#10;    /**&#10;     * Retrieves all contacts from the device's contact list&#10;     * Requires READ_CONTACTS permission&#10;     */&#10;    fun getPhoneContacts(context: Context): List&lt;PhoneContact&gt; {&#10;        val contacts = mutableListOf&lt;PhoneContact&gt;()&#10;        val seenIds = mutableSetOf&lt;String&gt;()&#10;&#10;        try {&#10;            val contentResolver = context.contentResolver&#10;            val cursor = contentResolver.query(&#10;                ContactsContract.CommonDataKinds.Phone.CONTENT_URI,&#10;                arrayOf(&#10;                    ContactsContract.CommonDataKinds.Phone.CONTACT_ID,&#10;                    ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME,&#10;                    ContactsContract.CommonDataKinds.Phone.NUMBER&#10;                ),&#10;                null,&#10;                null,&#10;                ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME + &quot; ASC&quot;&#10;            )&#10;&#10;            cursor?.use {&#10;                val idIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.CONTACT_ID)&#10;                val nameIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)&#10;                val numberIndex = it.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)&#10;&#10;                while (it.moveToNext()) {&#10;                    val id = it.getString(idIndex) ?: continue&#10;                    val name = it.getString(nameIndex) ?: &quot;Unknown&quot;&#10;                    val number = it.getString(numberIndex) ?: continue&#10;&#10;                    // Avoid duplicates - only add each contact once (first phone number)&#10;                    if (!seenIds.contains(id)) {&#10;                        seenIds.add(id)&#10;                        contacts.add(&#10;                            PhoneContact(&#10;                                id = id,&#10;                                name = name,&#10;                                phoneNumber = normalizePhoneNumber(number)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;        }&#10;&#10;        return contacts&#10;    }&#10;&#10;    /**&#10;     * Normalize phone number by removing spaces, dashes, and parentheses&#10;     */&#10;    private fun normalizePhoneNumber(number: String): String {&#10;        return number.replace(Regex(&quot;[\\s\\-()]&quot;), &quot;&quot;)&#10;    }&#10;&#10;    /**&#10;     * Search contacts by name or phone number&#10;     */&#10;    fun searchContacts(contacts: List&lt;PhoneContact&gt;, query: String): List&lt;PhoneContact&gt; {&#10;        if (query.isBlank()) return contacts&#10;        &#10;        val lowerQuery = query.lowercase()&#10;        return contacts.filter { contact -&gt;&#10;            contact.name.lowercase().contains(lowerQuery) ||&#10;            contact.phoneNumber.contains(query)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/utils/DataInitializer_fixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/utils/DataInitializer_fixed.kt" />
              <option name="updatedContent" value="package com.example.firstaidapp.utils&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.core.content.edit&#10;import com.example.firstaidapp.data.database.AppDatabase&#10;import com.example.firstaidapp.data.models.*&#10;import com.example.firstaidapp.utils.Constants.EMERGENCY_NUMBER_IN&#10;import com.example.firstaidapp.utils.Constants.POISON_CONTROL_IN&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;&#10;object DataInitializer {&#10;&#10;    private const val TAG = &quot;DataInitializer&quot;&#10;    private val isInitialized = AtomicBoolean(false)&#10;&#10;    /**&#10;     * Public non-blocking entry used by older callers: launches the suspending initializer on IO.&#10;     */&#10;    fun initializeData(context: Context) {&#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            initializeDataBlocking(context.applicationContext)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Suspends until initialization completes. This is the entrypoint used by WorkManager.&#10;     */&#10;    suspend fun initializeDataBlocking(context: Context) {&#10;        if (isInitialized.getAndSet(true)) {&#10;            Log.i(TAG, &quot;initializeData: Already initialized or in progress, skipping.&quot;)&#10;            return&#10;        }&#10;&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                Log.i(TAG, &quot;initializeData: starting initialization on IO thread (blocking)&quot;)&#10;                val database = AppDatabase.getDatabase(context)&#10;                val prefs = context.getSharedPreferences(&quot;first_aid_prefs&quot;, Context.MODE_PRIVATE)&#10;&#10;                val guidesCount = try { database.guideDao().getGuidesCount() } catch (e: Exception) { Log.e(TAG, &quot;count guides failed&quot;, e); 0 }&#10;                val contactsCount = try { database.contactDao().getContactsCount() } catch (e: Exception) { Log.e(TAG, &quot;count contacts failed&quot;, e); 0 }&#10;&#10;                Log.i(TAG, &quot;initializeData: guidesCount=$guidesCount, contactsCount=$contactsCount&quot;)&#10;&#10;                val expectedGuidesCount = 20&#10;                val needsFullReinitialization = guidesCount &lt; expectedGuidesCount&#10;&#10;                if (needsFullReinitialization) {&#10;                    Log.i(TAG, &quot;initializeData: forcing reinitialization - found $guidesCount guides, expected $expectedGuidesCount&quot;)&#10;&#10;                    database.guideDao().deleteAllGuides()&#10;                    database.contactDao().deleteAllContacts()&#10;&#10;                    try {&#10;                        Log.i(TAG, &quot;initializeData: initializing all $expectedGuidesCount guides&quot;)&#10;                        initializeGuides(database)&#10;                        Log.i(TAG, &quot;initializeData: guides initialized&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Error initializing guides&quot;, e)&#10;                        isInitialized.set(false) &#10;                        return@withContext&#10;                    }&#10;&#10;                    try {&#10;                        Log.i(TAG, &quot;initializeData: initializing contacts&quot;)&#10;                        initializeContacts(database)&#10;                        Log.i(TAG, &quot;initializeData: contacts initialized&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Error initializing contacts&quot;, e)&#10;                    }&#10;&#10;                    prefs.edit(commit = true) { putBoolean(&quot;data_initialized&quot;, true) }&#10;                    Log.i(TAG, &quot;initializeData: marked data_initialized=true&quot;)&#10;                } else {&#10;                    Log.i(TAG, &quot;initializeData: all guides already present ($guidesCount/$expectedGuidesCount)&quot;)&#10;                }&#10;&#10;            } catch (e: Throwable) {&#10;                Log.e(TAG, &quot;initializeData: unexpected error&quot;, e)&#10;                isInitialized.set(false) // Reset on failure to allow retry&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun initializeGuides(database: AppDatabase) {&#10;        val guides = listOf(&#10;            createCPRGuide(),&#10;            createChokingGuide(),&#10;            createBleedingGuide(),&#10;            createBurnsGuide(),&#10;            createFracturesGuide(),&#10;            createPoisoningGuide(),&#10;            createShockGuide(),&#10;            createHeartAttackGuide(),&#10;            createStrokeGuide(),&#10;            createAllergicReactionGuide(),&#10;            createSprainsStrainsGuide(),&#10;            createHypothermiaGuide(),&#10;            createHeatExhaustionGuide(),&#10;            createSeizuresGuide(),&#10;            createBitesStingsGuide(),&#10;            createAsthmaAttackGuide(),&#10;            createDiabeticEmergenciesGuide(),&#10;            createDrowningGuide(),&#10;            createNosebleedsGuide(),&#10;            createEyeInjuriesGuide()&#10;        )&#10;&#10;        for ((index, guide) in guides.withIndex()) {&#10;            try {&#10;                Log.i(TAG, &quot;insertGuide: inserting ${guide.id} (index=${index})&quot;)&#10;                database.guideDao().insertGuide(guide)&#10;                delay(50)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;insertGuide: failed to insert ${guide.id}&quot;, e)&#10;            }&#10;        }&#10;&#10;        Log.i(TAG, &quot;initializeGuides: completed inserting ${guides.size} guides&quot;)&#10;    }&#10;&#10;    private suspend fun initializeContacts(database: AppDatabase) {&#10;        val contacts = listOf(&#10;            EmergencyContact(&#10;                name = &quot;Emergency Services (All)&quot;,&#10;                phoneNumber = EMERGENCY_NUMBER_IN,&#10;                type = ContactType.EMERGENCY_SERVICE,&#10;                relationship = &quot;Emergency&quot;,&#10;                notes = &quot;Unified emergency number for Police, Fire, and Medical emergencies in India&quot;&#10;            ),&#10;            EmergencyContact(&#10;                name = &quot;Police&quot;,&#10;                phoneNumber = &quot;100&quot;,&#10;                type = ContactType.POLICE,&#10;                relationship = &quot;Emergency&quot;,&#10;                notes = &quot;Police emergency services&quot;&#10;            ),&#10;            EmergencyContact(&#10;                name = &quot;Fire Brigade&quot;,&#10;                phoneNumber = &quot;101&quot;,&#10;                type = ContactType.FIRE_DEPARTMENT,&#10;                relationship = &quot;Emergency&quot;,&#10;                notes = &quot;Fire and rescue services&quot;&#10;            ),&#10;            EmergencyContact(&#10;                name = &quot;Medical Emergency&quot;,&#10;                phoneNumber = &quot;108&quot;,&#10;                type = ContactType.EMERGENCY_SERVICE,&#10;                relationship = &quot;Emergency&quot;,&#10;                notes = &quot;Medical emergency and ambulance services&quot;&#10;            ),&#10;            EmergencyContact(&#10;                name = &quot;National Poison Information Centre&quot;,&#10;                phoneNumber = POISON_CONTROL_IN,&#10;                type = ContactType.POISON_CONTROL,&#10;                relationship = &quot;Emergency&quot;,&#10;                notes = &quot;24/7 poison emergency hotline in India&quot;&#10;            )&#10;        )&#10;&#10;        for ((index, contact) in contacts.withIndex()) {&#10;            try {&#10;                Log.i(TAG, &quot;insertContact: inserting ${contact.name} (index=${index})&quot;)&#10;                database.contactDao().insertContact(contact)&#10;                delay(30)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;insertContact: failed to insert ${contact.name}&quot;, e)&#10;            }&#10;        }&#10;&#10;        Log.i(TAG, &quot;initializeContacts: completed inserting ${contacts.size} contacts&quot;)&#10;    }&#10;&#10;    private fun createCPRGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;cpr_guide&quot;,&#10;            title = &quot;CPR (Cardiopulmonary Resuscitation)&quot;,&#10;            category = &quot;Life-Threatening&quot;,&#10;            severity = &quot;CRITICAL&quot;,&#10;            description = &quot;Learn how to perform CPR to save a life when someone's heart stops beating.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;cpr_step_1&quot;, guideId = &quot;cpr_guide&quot;, stepNumber = 1, title = &quot;Check Responsiveness&quot;, description = &quot;Tap shoulders and shout 'Are you okay?'&quot;, stepType = StepType.CHECK, isCritical = true),&#10;                GuideStep(id = &quot;cpr_step_2&quot;, guideId = &quot;cpr_guide&quot;, stepNumber = 2, title = &quot;Call for Help&quot;, description = &quot;Call 112 immediately&quot;, stepType = StepType.CALL, isCritical = true),&#10;                GuideStep(id = &quot;cpr_step_3&quot;, guideId = &quot;cpr_guide&quot;, stepNumber = 3, title = &quot;Position Patient&quot;, description = &quot;Position on firm surface, face up&quot;, stepType = StepType.ACTION),&#10;                GuideStep(id = &quot;cpr_step_4&quot;, guideId = &quot;cpr_guide&quot;, stepNumber = 4, title = &quot;Hand Placement&quot;, description = &quot;Place heel of hand on center of chest&quot;, stepType = StepType.ACTION, isCritical = true),&#10;                GuideStep(id = &quot;cpr_step_5&quot;, guideId = &quot;cpr_guide&quot;, stepNumber = 5, title = &quot;Chest Compressions&quot;, description = &quot;Push hard and fast at least 2 inches deep&quot;, stepType = StepType.ACTION, isCritical = true),&#10;                GuideStep(id = &quot;cpr_step_6&quot;, guideId = &quot;cpr_guide&quot;, stepNumber = 6, title = &quot;Continue Until Help Arrives&quot;, description = &quot;Keep doing compressions until emergency services arrive&quot;, stepType = StepType.REPEAT, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_cpr&quot;,&#10;            whenToCallEmergency = &quot;Person is unresponsive and not breathing normally&quot;,&#10;            warnings = listOf(&quot;Only perform if person is unresponsive&quot;, &quot;Don't be afraid to push hard&quot;),&#10;            estimatedTimeMinutes = 0,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createChokingGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;choking_guide&quot;,&#10;            title = &quot;Choking Emergency&quot;,&#10;            category = &quot;Respiratory&quot;,&#10;            severity = &quot;CRITICAL&quot;,&#10;            description = &quot;Quick response to save someone who is choking and cannot breathe.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;choking_step_1&quot;, guideId = &quot;choking_guide&quot;, stepNumber = 1, title = &quot;Assess Situation&quot;, description = &quot;Ask 'Are you choking?' - if they can't speak, act immediately&quot;, stepType = StepType.CHECK, isCritical = true),&#10;                GuideStep(id = &quot;choking_step_2&quot;, guideId = &quot;choking_guide&quot;, stepNumber = 2, title = &quot;Position Behind Person&quot;, description = &quot;Stand behind and wrap arms around waist&quot;, stepType = StepType.ACTION),&#10;                GuideStep(id = &quot;choking_step_3&quot;, guideId = &quot;choking_guide&quot;, stepNumber = 3, title = &quot;Abdominal Thrusts&quot;, description = &quot;Give quick upward thrusts into abdomen&quot;, stepType = StepType.ACTION, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_choking&quot;,&#10;            whenToCallEmergency = &quot;Person cannot speak, cough, or breathe&quot;,&#10;            warnings = listOf(&quot;Don't perform on pregnant women or infants&quot;),&#10;            estimatedTimeMinutes = 2,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createBleedingGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;bleeding_guide&quot;,&#10;            title = &quot;Severe Bleeding Control&quot;,&#10;            category = &quot;Trauma&quot;,&#10;            severity = &quot;HIGH&quot;,&#10;            description = &quot;Stop severe bleeding to prevent shock and save a life.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;bleeding_step_1&quot;, guideId = &quot;bleeding_guide&quot;, stepNumber = 1, title = &quot;Call Emergency&quot;, description = &quot;Call 112 for severe bleeding&quot;, stepType = StepType.CALL, isCritical = true),&#10;                GuideStep(id = &quot;bleeding_step_2&quot;, guideId = &quot;bleeding_guide&quot;, stepNumber = 2, title = &quot;Apply Direct Pressure&quot;, description = &quot;Apply direct pressure with clean cloth&quot;, stepType = StepType.ACTION, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_bleeding&quot;,&#10;            whenToCallEmergency = &quot;Heavy, continuous bleeding or blood spurting from wound&quot;,&#10;            estimatedTimeMinutes = 10,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createBurnsGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;burns_guide&quot;,&#10;            title = &quot;Burns Treatment&quot;,&#10;            category = &quot;Trauma&quot;,&#10;            severity = &quot;MEDIUM&quot;,&#10;            description = &quot;Proper treatment of burns to prevent infection and promote healing.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;burns_step_1&quot;, guideId = &quot;burns_guide&quot;, stepNumber = 1, title = &quot;Remove from Source&quot;, description = &quot;Remove person from heat source&quot;, stepType = StepType.SAFETY, isCritical = true),&#10;                GuideStep(id = &quot;burns_step_2&quot;, guideId = &quot;burns_guide&quot;, stepNumber = 2, title = &quot;Cool the Burn&quot;, description = &quot;Cool with lukewarm water for 10-20 minutes&quot;, stepType = StepType.ACTION, isCritical = true),&#10;                GuideStep(id = &quot;burns_step_3&quot;, guideId = &quot;burns_guide&quot;, stepNumber = 3, title = &quot;Apply Bandage&quot;, description = &quot;Apply loose, sterile bandage&quot;, stepType = StepType.ACTION)&#10;            ),&#10;            iconResName = &quot;ic_burns&quot;,&#10;            whenToCallEmergency = &quot;Burns larger than palm size or white/charred skin&quot;,&#10;            warnings = listOf(&quot;Don't use ice water&quot;, &quot;Don't apply butter or oil&quot;),&#10;            estimatedTimeMinutes = 20,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createFracturesGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;fractures_guide&quot;,&#10;            title = &quot;Broken Bones &amp; Fractures&quot;,&#10;            category = &quot;Trauma&quot;,&#10;            severity = &quot;MEDIUM&quot;,&#10;            description = &quot;Immobilize and stabilize suspected fractures to prevent further injury.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;fractures_step_1&quot;, guideId = &quot;fractures_guide&quot;, stepNumber = 1, title = &quot;Don't Move Person&quot;, description = &quot;Don't move unless in immediate danger&quot;, stepType = StepType.SAFETY, isCritical = true),&#10;                GuideStep(id = &quot;fractures_step_2&quot;, guideId = &quot;fractures_guide&quot;, stepNumber = 2, title = &quot;Call Emergency&quot;, description = &quot;Call 112 for obvious fractures&quot;, stepType = StepType.EMERGENCY_CALL),&#10;                GuideStep(id = &quot;fractures_step_3&quot;, guideId = &quot;fractures_guide&quot;, stepNumber = 3, title = &quot;Immobilize Area&quot;, description = &quot;Immobilize above and below fracture&quot;, stepType = StepType.ACTION, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_fracture&quot;,&#10;            whenToCallEmergency = &quot;Obvious deformity or bone visible through skin&quot;,&#10;            warnings = listOf(&quot;Don't try to realign broken bones&quot;),&#10;            estimatedTimeMinutes = 15,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createPoisoningGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;poisoning_guide&quot;,&#10;            title = &quot;Poisoning Emergency&quot;,&#10;            category = &quot;Medical Emergency&quot;,&#10;            severity = &quot;HIGH&quot;,&#10;            description = &quot;Respond quickly to poisoning emergencies and prevent absorption.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;poisoning_step_1&quot;, guideId = &quot;poisoning_guide&quot;, stepNumber = 1, title = &quot;Call Poison Control&quot;, description = &quot;Call National Poison Information Centre immediately&quot;, stepType = StepType.CALL, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_poisoning&quot;,&#10;            whenToCallEmergency = &quot;If person is unconscious, having a seizure, or trouble breathing&quot;,&#10;            warnings = listOf(&quot;Do not induce vomiting unless told to do so&quot;),&#10;            estimatedTimeMinutes = 5,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createShockGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;shock_guide&quot;,&#10;            title = &quot;Treating for Shock&quot;,&#10;            category = &quot;Medical Emergency&quot;,&#10;            severity = &quot;CRITICAL&quot;,&#10;            description = &quot;Recognize and treat shock, a life-threatening condition.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;shock_step_1&quot;, guideId = &quot;shock_guide&quot;, stepNumber = 1, title = &quot;Call Emergency&quot;, description = &quot;Call 112 immediately&quot;, stepType = StepType.EMERGENCY_CALL, isCritical = true),&#10;                GuideStep(id = &quot;shock_step_2&quot;, guideId = &quot;shock_guide&quot;, stepNumber = 2, title = &quot;Lay Person Down&quot;, description = &quot;Lay person down and elevate legs&quot;, stepType = StepType.ACTION, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_shock&quot;,&#10;            whenToCallEmergency = &quot;Any signs of shock (clammy skin, weak pulse, confusion)&quot;,&#10;            estimatedTimeMinutes = 10,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createHeartAttackGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;heart_attack_guide&quot;,&#10;            title = &quot;Heart Attack Response&quot;,&#10;            category = &quot;Medical Emergency&quot;,&#10;            severity = &quot;CRITICAL&quot;,&#10;            description = &quot;Recognize the signs of a heart attack and take immediate action.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;heart_attack_step_1&quot;, guideId = &quot;heart_attack_guide&quot;, stepNumber = 1, title = &quot;Call Emergency&quot;, description = &quot;Call 112 immediately&quot;, stepType = StepType.EMERGENCY_CALL, isCritical = true),&#10;                GuideStep(id = &quot;heart_attack_step_2&quot;, guideId = &quot;heart_attack_guide&quot;, stepNumber = 2, title = &quot;Help Person Rest&quot;, description = &quot;Have person sit down and rest&quot;, stepType = StepType.ACTION)&#10;            ),&#10;            iconResName = &quot;ic_heart_attack&quot;,&#10;            whenToCallEmergency = &quot;Chest pain, shortness of breath, or other heart attack signs&quot;,&#10;            warnings = listOf(&quot;Do not let the person drive to the hospital&quot;),&#10;            estimatedTimeMinutes = 5,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createStrokeGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;stroke_guide&quot;,&#10;            title = &quot;Stroke (Brain Attack)&quot;,&#10;            category = &quot;Medical Emergency&quot;,&#10;            severity = &quot;CRITICAL&quot;,&#10;            description = &quot;Recognize and respond to the signs of a stroke using the F.A.S.T. method.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;stroke_step_1&quot;, guideId = &quot;stroke_guide&quot;, stepNumber = 1, title = &quot;Call Emergency&quot;, description = &quot;Call 112 immediately&quot;, stepType = StepType.EMERGENCY_CALL, isCritical = true),&#10;                GuideStep(id = &quot;stroke_step_2&quot;, guideId = &quot;stroke_guide&quot;, stepNumber = 2, title = &quot;Note the Time&quot;, description = &quot;Note the time when first symptoms appeared&quot;, stepType = StepType.CHECK, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_stroke&quot;,&#10;            whenToCallEmergency = &quot;Any sign of stroke (face drooping, arm weakness, speech difficulty)&quot;,&#10;            estimatedTimeMinutes = 5,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createAllergicReactionGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;allergic_reaction_guide&quot;,&#10;            title = &quot;Anaphylaxis &amp; Severe Allergic Reactions&quot;,&#10;            category = &quot;Medical Emergency&quot;,&#10;            severity = &quot;CRITICAL&quot;,&#10;            description = &quot;Administer an epinephrine auto-injector and provide care for a severe allergic reaction.&quot;,&#10;            steps = listOf(&#10;                GuideStep(id = &quot;allergic_step_1&quot;, guideId = &quot;allergic_reaction_guide&quot;, stepNumber = 1, title = &quot;Use Epinephrine Auto-Injector&quot;, description = &quot;Help person use their epinephrine auto-injector&quot;, stepType = StepType.ACTION, isCritical = true),&#10;                GuideStep(id = &quot;allergic_step_2&quot;, guideId = &quot;allergic_reaction_guide&quot;, stepNumber = 2, title = &quot;Call Emergency&quot;, description = &quot;Call 112 even after using injector&quot;, stepType = StepType.EMERGENCY_CALL, isCritical = true)&#10;            ),&#10;            iconResName = &quot;ic_allergy&quot;,&#10;            whenToCallEmergency = &quot;Difficulty breathing, swelling of lips or tongue&quot;,&#10;            warnings = listOf(&quot;A second dose of epinephrine may be needed&quot;),&#10;            estimatedTimeMinutes = 10,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createSprainsStrainsGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;sprains_strains_guide&quot;,&#10;            title = &quot;Sprains and Strains&quot;,&#10;            category = &quot;Trauma&quot;,&#10;            severity = &quot;LOW&quot;,&#10;            description = &quot;Provide basic care for sprains and strains using the R.I.C.E. method.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_sprain&quot;,&#10;            whenToCallEmergency = &quot;If you can't move the injured joint or it's numb&quot;,&#10;            estimatedTimeMinutes = 20,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createHypothermiaGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;hypothermia_guide&quot;,&#10;            title = &quot;Hypothermia Care&quot;,&#10;            category = &quot;Environmental&quot;,&#10;            severity = &quot;HIGH&quot;,&#10;            description = &quot;Warm someone who is dangerously cold and prevent further heat loss.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_hypothermia&quot;,&#10;            whenToCallEmergency = &quot;Loss of consciousness, slow breathing, or weak pulse&quot;,&#10;            warnings = listOf(&quot;Do not use direct heat like hot water or heating pads&quot;),&#10;            estimatedTimeMinutes = 30,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createHeatExhaustionGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;heat_exhaustion_guide&quot;,&#10;            title = &quot;Heat Exhaustion&quot;,&#10;            category = &quot;Environmental&quot;,&#10;            severity = &quot;MEDIUM&quot;,&#10;            description = &quot;Cool down someone who is overheating to prevent heatstroke.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_heat_exhaustion&quot;,&#10;            whenToCallEmergency = &quot;If person's condition worsens or they become unconscious&quot;,&#10;            estimatedTimeMinutes = 30,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createSeizuresGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;seizures_guide&quot;,&#10;            title = &quot;Seizures &amp; Epilepsy&quot;,&#10;            category = &quot;Medical Emergency&quot;,&#10;            severity = &quot;HIGH&quot;,&#10;            description = &quot;Protect someone having a seizure from injury.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_seizure&quot;,&#10;            whenToCallEmergency = &quot;Seizure lasts more than 5 minutes or person is injured&quot;,&#10;            warnings = listOf(&quot;Do not put anything in the person's mouth&quot;),&#10;            estimatedTimeMinutes = 10,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createBitesStingsGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;bites_stings_guide&quot;,&#10;            title = &quot;Insect Bites &amp; Stings&quot;,&#10;            category = &quot;Trauma&quot;,&#10;            severity = &quot;LOW&quot;,&#10;            description = &quot;Provide comfort and care for common insect bites and stings.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_bites_stings&quot;,&#10;            whenToCallEmergency = &quot;Signs of a severe allergic reaction (anaphylaxis)&quot;,&#10;            estimatedTimeMinutes = 15,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createAsthmaAttackGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;asthma_attack_guide&quot;,&#10;            title = &quot;Asthma Attack&quot;,&#10;            category = &quot;Respiratory&quot;,&#10;            severity = &quot;HIGH&quot;,&#10;            description = &quot;Help someone use their inhaler and manage an asthma attack.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_asthma&quot;,&#10;            whenToCallEmergency = &quot;If the person's inhaler is not helping or they can't speak&quot;,&#10;            estimatedTimeMinutes = 10,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createDiabeticEmergenciesGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;diabetic_emergencies_guide&quot;,&#10;            title = &quot;Diabetic Emergencies&quot;,&#10;            category = &quot;Medical Emergency&quot;,&#10;            severity = &quot;HIGH&quot;,&#10;            description = &quot;Recognize and help with low blood sugar (hypoglycemia).&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_diabetic&quot;,&#10;            whenToCallEmergency = &quot;If the person becomes unresponsive or can't swallow&quot;,&#10;            warnings = listOf(&quot;Do not give insulin unless you are trained to do so&quot;),&#10;            estimatedTimeMinutes = 15,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createDrowningGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;drowning_guide&quot;,&#10;            title = &quot;Drowning Response&quot;,&#10;            category = &quot;Life-Threatening&quot;,&#10;            severity = &quot;CRITICAL&quot;,&#10;            description = &quot;Provide rescue breaths and care after pulling someone from the water.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_drowning&quot;,&#10;            whenToCallEmergency = &quot;Always call for any drowning incident&quot;,&#10;            estimatedTimeMinutes = 5,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;&#10;    private fun createNosebleedsGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;nosebleeds_guide&quot;,&#10;            title = &quot;Nosebleeds&quot;,&#10;            category = &quot;Trauma&quot;,&#10;            severity = &quot;LOW&quot;,&#10;            description = &quot;Simple steps to stop a common nosebleed.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_nosebleed&quot;,&#10;            whenToCallEmergency = &quot;If bleeding doesn't stop after 20 minutes&quot;,&#10;            estimatedTimeMinutes = 20,&#10;            difficulty = &quot;Beginner&quot;&#10;        )&#10;    }&#10;&#10;    private fun createEyeInjuriesGuide(): FirstAidGuide {&#10;        return FirstAidGuide(&#10;            id = &quot;eye_injuries_guide&quot;,&#10;            title = &quot;Eye Injuries&quot;,&#10;            category = &quot;Trauma&quot;,&#10;            severity = &quot;MEDIUM&quot;,&#10;            description = &quot;Care for chemical splashes or foreign objects in the eye.&quot;,&#10;            steps = emptyList(),&#10;            iconResName = &quot;ic_eye_injury&quot;,&#10;            whenToCallEmergency = &quot;For any major eye injury or vision loss&quot;,&#10;            warnings = listOf(&quot;Do not rub the eye&quot;),&#10;            estimatedTimeMinutes = 15,&#10;            difficulty = &quot;Intermediate&quot;&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/utils/UserPreferencesManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/utils/UserPreferencesManager.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;&#10;class UserPreferencesManager(context: Context) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;    companion object {&#10;        private const val PREFS_NAME = &quot;FirstAidUserPrefs&quot;&#10;&#10;        // Theme preferences&#10;        private const val KEY_THEME_MODE = &quot;theme_mode&quot;&#10;        private const val KEY_DARK_MODE = &quot;dark_mode&quot;&#10;&#10;        // App preferences&#10;        private const val KEY_SOUND_ENABLED = &quot;sound_enabled&quot;&#10;        private const val KEY_VIBRATION_ENABLED = &quot;vibration_enabled&quot;&#10;        private const val KEY_EMERGENCY_CONFIRMATION = &quot;emergency_confirmation&quot;&#10;&#10;        // Guide preferences&#10;        private const val KEY_FONT_SIZE = &quot;font_size&quot;&#10;        private const val KEY_SHOW_IMAGES = &quot;show_images&quot;&#10;        private const val KEY_AUTO_SCROLL = &quot;auto_scroll&quot;&#10;&#10;        // Search preferences&#10;        private const val KEY_SAVE_SEARCH_HISTORY = &quot;save_search_history&quot;&#10;        private const val KEY_CLEAR_HISTORY_ON_EXIT = &quot;clear_history_on_exit&quot;&#10;&#10;        // Privacy preferences&#10;        private const val KEY_ANALYTICS_ENABLED = &quot;analytics_enabled&quot;&#10;        private const val KEY_CRASH_REPORTING = &quot;crash_reporting&quot;&#10;&#10;        // Emergency preferences&#10;        private const val KEY_QUICK_DIAL_ENABLED = &quot;quick_dial_enabled&quot;&#10;        private const val KEY_EMERGENCY_CONTACTS_COUNT = &quot;emergency_contacts_count&quot;&#10;&#10;        // Onboarding&#10;        private const val KEY_FIRST_TIME_USER = &quot;first_time_user&quot;&#10;        private const val KEY_TUTORIAL_COMPLETED = &quot;tutorial_completed&quot;&#10;&#10;        // State selection for contacts&#10;        private const val KEY_SELECTED_STATE = &quot;selected_state&quot;&#10;        private const val KEY_STATE_SELECTION_DONE = &quot;state_selection_done&quot;&#10;    }&#10;&#10;    // Theme Settings&#10;    var isDarkModeEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_DARK_MODE, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_DARK_MODE, value).apply()&#10;&#10;    var themeMode: String&#10;        get() = prefs.getString(KEY_THEME_MODE, &quot;system&quot;) ?: &quot;system&quot;&#10;        set(value) = prefs.edit().putString(KEY_THEME_MODE, value).apply()&#10;&#10;    // App Settings&#10;    var isSoundEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_SOUND_ENABLED, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_SOUND_ENABLED, value).apply()&#10;&#10;    var isVibrationEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_VIBRATION_ENABLED, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_VIBRATION_ENABLED, value).apply()&#10;&#10;    var requireEmergencyConfirmation: Boolean&#10;        get() = prefs.getBoolean(KEY_EMERGENCY_CONFIRMATION, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_EMERGENCY_CONFIRMATION, value).apply()&#10;&#10;    // Guide Settings&#10;    var fontSize: String&#10;        get() = prefs.getString(KEY_FONT_SIZE, &quot;medium&quot;) ?: &quot;medium&quot;&#10;        set(value) = prefs.edit().putString(KEY_FONT_SIZE, value).apply()&#10;&#10;    var showImages: Boolean&#10;        get() = prefs.getBoolean(KEY_SHOW_IMAGES, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_SHOW_IMAGES, value).apply()&#10;&#10;    var autoScroll: Boolean&#10;        get() = prefs.getBoolean(KEY_AUTO_SCROLL, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_AUTO_SCROLL, value).apply()&#10;&#10;    // Search Settings&#10;    var saveSearchHistory: Boolean&#10;        get() = prefs.getBoolean(KEY_SAVE_SEARCH_HISTORY, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_SAVE_SEARCH_HISTORY, value).apply()&#10;&#10;    var clearHistoryOnExit: Boolean&#10;        get() = prefs.getBoolean(KEY_CLEAR_HISTORY_ON_EXIT, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_CLEAR_HISTORY_ON_EXIT, value).apply()&#10;&#10;    // Privacy Settings&#10;    var analyticsEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_ANALYTICS_ENABLED, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_ANALYTICS_ENABLED, value).apply()&#10;&#10;    var crashReportingEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_CRASH_REPORTING, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_CRASH_REPORTING, value).apply()&#10;&#10;    // Emergency Settings&#10;    var quickDialEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_QUICK_DIAL_ENABLED, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_QUICK_DIAL_ENABLED, value).apply()&#10;&#10;    var emergencyContactsCount: Int&#10;        get() = prefs.getInt(KEY_EMERGENCY_CONTACTS_COUNT, 5)&#10;        set(value) = prefs.edit().putInt(KEY_EMERGENCY_CONTACTS_COUNT, value).apply()&#10;&#10;    // Onboarding&#10;    var isFirstTimeUser: Boolean&#10;        get() = prefs.getBoolean(KEY_FIRST_TIME_USER, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_FIRST_TIME_USER, value).apply()&#10;&#10;    var isTutorialCompleted: Boolean&#10;        get() = prefs.getBoolean(KEY_TUTORIAL_COMPLETED, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_TUTORIAL_COMPLETED, value).apply()&#10;&#10;    // State Selection for Contacts&#10;    var selectedState: String&#10;        get() = prefs.getString(KEY_SELECTED_STATE, &quot;National&quot;) ?: &quot;National&quot;&#10;        set(value) = prefs.edit().putString(KEY_SELECTED_STATE, value).apply()&#10;&#10;    var isStateSelectionDone: Boolean&#10;        get() = prefs.getBoolean(KEY_STATE_SELECTION_DONE, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_STATE_SELECTION_DONE, value).apply()&#10;&#10;    // Utility methods&#10;    fun resetToDefaults() {&#10;        prefs.edit().clear().apply()&#10;    }&#10;&#10;    fun exportPreferences(): Map&lt;String, Any?&gt; {&#10;        return prefs.all&#10;    }&#10;&#10;    fun importPreferences(preferences: Map&lt;String, Any?&gt;) {&#10;        val editor = prefs.edit()&#10;        preferences.forEach { (key, value) -&gt;&#10;            when (value) {&#10;                is Boolean -&gt; editor.putBoolean(key, value)&#10;                is String -&gt; editor.putString(key, value)&#10;                is Int -&gt; editor.putInt(key, value)&#10;                is Float -&gt; editor.putFloat(key, value)&#10;                is Long -&gt; editor.putLong(key, value)&#10;            }&#10;        }&#10;        editor.apply()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;&#10;class UserPreferencesManager(context: Context) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;&#10;    companion object {&#10;        private const val PREFS_NAME = &quot;FirstAidUserPrefs&quot;&#10;&#10;        // Theme preferences&#10;        private const val KEY_THEME_MODE = &quot;theme_mode&quot;&#10;        private const val KEY_DARK_MODE = &quot;dark_mode&quot;&#10;&#10;        // App preferences&#10;        private const val KEY_SOUND_ENABLED = &quot;sound_enabled&quot;&#10;        private const val KEY_VIBRATION_ENABLED = &quot;vibration_enabled&quot;&#10;        private const val KEY_EMERGENCY_CONFIRMATION = &quot;emergency_confirmation&quot;&#10;&#10;        // Guide preferences&#10;        private const val KEY_FONT_SIZE = &quot;font_size&quot;&#10;        private const val KEY_SHOW_IMAGES = &quot;show_images&quot;&#10;        private const val KEY_AUTO_SCROLL = &quot;auto_scroll&quot;&#10;&#10;        // Search preferences&#10;        private const val KEY_SAVE_SEARCH_HISTORY = &quot;save_search_history&quot;&#10;        private const val KEY_CLEAR_HISTORY_ON_EXIT = &quot;clear_history_on_exit&quot;&#10;&#10;        // Privacy preferences&#10;        private const val KEY_ANALYTICS_ENABLED = &quot;analytics_enabled&quot;&#10;        private const val KEY_CRASH_REPORTING = &quot;crash_reporting&quot;&#10;&#10;        // Emergency preferences&#10;        private const val KEY_QUICK_DIAL_ENABLED = &quot;quick_dial_enabled&quot;&#10;        private const val KEY_EMERGENCY_CONTACTS_COUNT = &quot;emergency_contacts_count&quot;&#10;&#10;        // Onboarding&#10;        private const val KEY_FIRST_TIME_USER = &quot;first_time_user&quot;&#10;        private const val KEY_TUTORIAL_COMPLETED = &quot;tutorial_completed&quot;&#10;&#10;        // State selection for contacts&#10;        private const val KEY_SELECTED_STATE = &quot;selected_state&quot;&#10;        private const val KEY_STATE_SELECTION_DONE = &quot;state_selection_done&quot;&#10;&#10;        // Contacts permission tracking&#10;        private const val KEY_CONTACTS_PERMISSION_ASKED = &quot;contacts_permission_asked&quot;&#10;        private const val KEY_CONTACTS_PERMISSION_GRANTED = &quot;contacts_permission_granted&quot;&#10;    }&#10;&#10;    // Theme Settings&#10;    var isDarkModeEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_DARK_MODE, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_DARK_MODE, value).apply()&#10;&#10;    var themeMode: String&#10;        get() = prefs.getString(KEY_THEME_MODE, &quot;system&quot;) ?: &quot;system&quot;&#10;        set(value) = prefs.edit().putString(KEY_THEME_MODE, value).apply()&#10;&#10;    // App Settings&#10;    var isSoundEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_SOUND_ENABLED, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_SOUND_ENABLED, value).apply()&#10;&#10;    var isVibrationEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_VIBRATION_ENABLED, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_VIBRATION_ENABLED, value).apply()&#10;&#10;    var requireEmergencyConfirmation: Boolean&#10;        get() = prefs.getBoolean(KEY_EMERGENCY_CONFIRMATION, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_EMERGENCY_CONFIRMATION, value).apply()&#10;&#10;    // Guide Settings&#10;    var fontSize: String&#10;        get() = prefs.getString(KEY_FONT_SIZE, &quot;medium&quot;) ?: &quot;medium&quot;&#10;        set(value) = prefs.edit().putString(KEY_FONT_SIZE, value).apply()&#10;&#10;    var showImages: Boolean&#10;        get() = prefs.getBoolean(KEY_SHOW_IMAGES, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_SHOW_IMAGES, value).apply()&#10;&#10;    var autoScroll: Boolean&#10;        get() = prefs.getBoolean(KEY_AUTO_SCROLL, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_AUTO_SCROLL, value).apply()&#10;&#10;    // Search Settings&#10;    var saveSearchHistory: Boolean&#10;        get() = prefs.getBoolean(KEY_SAVE_SEARCH_HISTORY, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_SAVE_SEARCH_HISTORY, value).apply()&#10;&#10;    var clearHistoryOnExit: Boolean&#10;        get() = prefs.getBoolean(KEY_CLEAR_HISTORY_ON_EXIT, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_CLEAR_HISTORY_ON_EXIT, value).apply()&#10;&#10;    // Privacy Settings&#10;    var analyticsEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_ANALYTICS_ENABLED, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_ANALYTICS_ENABLED, value).apply()&#10;&#10;    var crashReportingEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_CRASH_REPORTING, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_CRASH_REPORTING, value).apply()&#10;&#10;    // Emergency Settings&#10;    var quickDialEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_QUICK_DIAL_ENABLED, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_QUICK_DIAL_ENABLED, value).apply()&#10;&#10;    var emergencyContactsCount: Int&#10;        get() = prefs.getInt(KEY_EMERGENCY_CONTACTS_COUNT, 5)&#10;        set(value) = prefs.edit().putInt(KEY_EMERGENCY_CONTACTS_COUNT, value).apply()&#10;&#10;    // Onboarding&#10;    var isFirstTimeUser: Boolean&#10;        get() = prefs.getBoolean(KEY_FIRST_TIME_USER, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_FIRST_TIME_USER, value).apply()&#10;&#10;    var isTutorialCompleted: Boolean&#10;        get() = prefs.getBoolean(KEY_TUTORIAL_COMPLETED, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_TUTORIAL_COMPLETED, value).apply()&#10;&#10;    // State Selection for Contacts&#10;    var selectedState: String&#10;        get() = prefs.getString(KEY_SELECTED_STATE, &quot;National&quot;) ?: &quot;National&quot;&#10;        set(value) = prefs.edit().putString(KEY_SELECTED_STATE, value).apply()&#10;&#10;    var isStateSelectionDone: Boolean&#10;        get() = prefs.getBoolean(KEY_STATE_SELECTION_DONE, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_STATE_SELECTION_DONE, value).apply()&#10;&#10;    // Contacts Permission Tracking&#10;    var hasAskedContactsPermission: Boolean&#10;        get() = prefs.getBoolean(KEY_CONTACTS_PERMISSION_ASKED, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_CONTACTS_PERMISSION_ASKED, value).apply()&#10;&#10;    var contactsPermissionGranted: Boolean&#10;        get() = prefs.getBoolean(KEY_CONTACTS_PERMISSION_GRANTED, false)&#10;        set(value) = prefs.edit().putBoolean(KEY_CONTACTS_PERMISSION_GRANTED, value).apply()&#10;&#10;    // Utility methods&#10;    fun resetToDefaults() {&#10;        prefs.edit().clear().apply()&#10;    }&#10;&#10;    fun exportPreferences(): Map&lt;String, Any?&gt; {&#10;        return prefs.all&#10;    }&#10;&#10;    fun importPreferences(preferences: Map&lt;String, Any?&gt;) {&#10;        val editor = prefs.edit()&#10;        preferences.forEach { (key, value) -&gt;&#10;            when (value) {&#10;                is Boolean -&gt; editor.putBoolean(key, value)&#10;                is String -&gt; editor.putString(key, value)&#10;                is Int -&gt; editor.putInt(key, value)&#10;                is Float -&gt; editor.putFloat(key, value)&#10;                is Long -&gt; editor.putLong(key, value)&#10;            }&#10;        }&#10;        editor.apply()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/dialog_phone_contacts_picker.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/dialog_phone_contacts_picker.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Select Contact&quot;&#10;        android:textColor=&quot;@color/text_primary&quot;&#10;        android:textSize=&quot;20sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:paddingBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Choose a contact from your phone&quot;&#10;        android:textColor=&quot;@color/text_secondary&quot;&#10;        android:textSize=&quot;14sp&quot;&#10;        android:paddingBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;!-- Search Box --&gt;&#10;    &lt;com.google.android.material.textfield.TextInputLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:hint=&quot;Search contacts...&quot;&#10;        style=&quot;@style/Widget.Material3.TextInputLayout.OutlinedBox&quot;&#10;        app:startIconDrawable=&quot;@android:drawable/ic_menu_search&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&gt;&#10;&#10;        &lt;com.google.android.material.textfield.TextInputEditText&#10;            android:id=&quot;@+id/etSearchPhoneContacts&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:inputType=&quot;text&quot;&#10;            android:maxLines=&quot;1&quot; /&gt;&#10;&#10;    &lt;/com.google.android.material.textfield.TextInputLayout&gt;&#10;&#10;    &lt;!-- Contact List --&gt;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/rvPhoneContacts&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:scrollbars=&quot;vertical&quot; /&gt;&#10;&#10;    &lt;!-- Empty State --&gt;&#10;    &lt;LinearLayout&#10;        android:id=&quot;@+id/layoutEmptyState&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:visibility=&quot;gone&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;No contacts found&quot;&#10;            android:textColor=&quot;@color/text_secondary&quot;&#10;            android:textSize=&quot;16sp&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Loading State --&gt;&#10;    &lt;ProgressBar&#10;        android:id=&quot;@+id/progressBar&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        android:visibility=&quot;gone&quot; /&gt;&#10;&#10;    &lt;!-- Cancel Button --&gt;&#10;    &lt;com.google.android.material.button.MaterialButton&#10;        android:id=&quot;@+id/btnCancelPicker&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Cancel&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        style=&quot;@style/Widget.Material3.Button.OutlinedButton&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>