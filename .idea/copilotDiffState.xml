<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/ContactsFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/contacts/ContactsFragment.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.contacts&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.TextWatcher&#10;import android.view.HapticFeedbackConstants&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AutoCompleteTextView&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.firstaidapp.R&#10;import com.example.firstaidapp.data.models.ContactType&#10;import com.example.firstaidapp.data.models.EmergencyContact&#10;import com.example.firstaidapp.databinding.FragmentContactsBinding&#10;import com.google.android.material.snackbar.Snackbar&#10;&#10;class ContactsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentContactsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var viewModel: ContactsViewModel&#10;    private lateinit var contactsAdapter: ContactsAdapter&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted, can make direct call&#10;            Snackbar.make(binding.root, &quot;Permission granted! Tap call button again to make direct call&quot;, Snackbar.LENGTH_SHORT).show()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Using dialer instead&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentContactsBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        setupViewModel()&#10;        setupRecyclerView()&#10;        setupObservers()&#10;        setupClickListeners()&#10;        setupSearchFunctionality()&#10;    }&#10;&#10;    private fun setupViewModel() {&#10;        val factory = ContactsViewModelFactory(requireActivity().application)&#10;        viewModel = ViewModelProvider(this, factory)[ContactsViewModel::class.java]&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        contactsAdapter = ContactsAdapter { contact -&gt;&#10;            makePhoneCall(contact.phoneNumber)&#10;        }&#10;&#10;        binding.rvContacts.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = contactsAdapter&#10;        }&#10;    }&#10;&#10;    private fun setupObservers() {&#10;        viewModel.allContacts.observe(viewLifecycleOwner) { contacts -&gt;&#10;            contactsAdapter.submitList(contacts)&#10;        }&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.btnSettings.setOnClickListener {&#10;            // Use basic navigation instead of SafeArgs for compatibility&#10;            findNavController().navigate(R.id.navigation_settings)&#10;        }&#10;&#10;        binding.fabAddContact.setOnClickListener {&#10;            showAddContactDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupSearchFunctionality() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return&#10;&#10;        binding.etSearchContacts.addTextChangedListener(object : TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                // Add null check&#10;                if (_binding == null) return&#10;&#10;                val query = s.toString()&#10;&#10;                // Removed all animations - immediate search instead&#10;                if (query.isNotEmpty()) {&#10;                    try {&#10;                        viewModel.searchContacts(query)&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                } else {&#10;                    try {&#10;                        viewModel.clearSearch()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;            }&#10;&#10;            override fun afterTextChanged(s: Editable?) {}&#10;        })&#10;&#10;        // Removed focus animations - basic functionality only&#10;        binding.etSearchContacts.setOnFocusChangeListener { view, hasFocus -&gt;&#10;            if (_binding == null) return@setOnFocusChangeListener&#10;            // No animations - just basic elevation change&#10;            if (hasFocus) {&#10;                view.elevation = 8f&#10;            } else {&#10;                view.elevation = 2f&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showAddContactDialog() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_add_contact, null)&#10;&#10;            val dialog = androidx.appcompat.app.AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;&#10;            // Get dialog views&#10;            val etContactName = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etContactName)&#10;            val etPhoneNumber = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etPhoneNumber)&#10;            val etRelationship = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etRelationship)&#10;            val spinnerContactType = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.spinnerContactType)&#10;            val etNotes = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etNotes)&#10;            val btnImportFromPhone = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnImportFromPhone)&#10;            val btnCancel = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnCancel)&#10;            val btnSave = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnSave)&#10;&#10;            // Null checks for all views&#10;            if (etContactName == null || etPhoneNumber == null || spinnerContactType == null ||&#10;                btnImportFromPhone == null || btnCancel == null || btnSave == null) {&#10;                return&#10;            }&#10;&#10;            // Setup contact type dropdown&#10;            setupContactTypeDropdown(spinnerContactType)&#10;&#10;            // Setup click listeners with null checks&#10;            btnImportFromPhone.setOnClickListener {&#10;                dialog.dismiss()&#10;                if (isAdded &amp;&amp; _binding != null) {&#10;                    openPhoneContactsSelection()&#10;                }&#10;            }&#10;&#10;            btnCancel.setOnClickListener {&#10;                dialog.dismiss()&#10;            }&#10;&#10;            btnSave.setOnClickListener {&#10;                if (!isAdded || _binding == null) {&#10;                    dialog.dismiss()&#10;                    return@setOnClickListener&#10;                }&#10;&#10;                val name = etContactName.text?.toString()?.trim() ?: &quot;&quot;&#10;                val phone = etPhoneNumber.text?.toString()?.trim() ?: &quot;&quot;&#10;                val relationship = etRelationship.text?.toString()?.trim() ?: &quot;&quot;&#10;                val typeString = spinnerContactType.text?.toString() ?: &quot;Personal&quot;&#10;                val notes = etNotes.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;                if (validateContactInput(name, phone)) {&#10;                    val contactType = when (typeString) {&#10;                        &quot;Emergency Service&quot; -&gt; ContactType.EMERGENCY_SERVICE&#10;                        &quot;Poison Control&quot; -&gt; ContactType.POISON_CONTROL&#10;                        &quot;Hospital&quot; -&gt; ContactType.HOSPITAL&#10;                        &quot;Police&quot; -&gt; ContactType.POLICE&#10;                        &quot;Fire Department&quot; -&gt; ContactType.FIRE_DEPARTMENT&#10;                        &quot;Family&quot; -&gt; ContactType.FAMILY&#10;                        &quot;Doctor&quot; -&gt; ContactType.DOCTOR&#10;                        &quot;Veterinarian&quot; -&gt; ContactType.VETERINARIAN&#10;                        &quot;Other&quot; -&gt; ContactType.OTHER&#10;                        else -&gt; ContactType.PERSONAL&#10;                    }&#10;&#10;                    val contact = EmergencyContact(&#10;                        name = name,&#10;                        phoneNumber = phone,&#10;                        relationship = relationship,&#10;                        type = contactType,&#10;                        notes = notes&#10;                    )&#10;&#10;                    try {&#10;                        viewModel.addContact(contact)&#10;&#10;                        // Removed animation - show immediate success message&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Contact added successfully!&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;&#10;                        dialog.dismiss()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Error adding contact: ${e.message}&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error opening add contact dialog&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupContactTypeDropdown(spinner: AutoCompleteTextView) {&#10;        val contactTypes = arrayOf(&#10;            &quot;Personal&quot;,&#10;            &quot;Family&quot;,&#10;            &quot;Emergency Service&quot;,&#10;            &quot;Hospital&quot;,&#10;            &quot;Police&quot;,&#10;            &quot;Fire Department&quot;,&#10;            &quot;Poison Control&quot;,&#10;            &quot;Doctor&quot;,&#10;            &quot;Veterinarian&quot;,&#10;            &quot;Other&quot;&#10;        )&#10;&#10;        val adapter = android.widget.ArrayAdapter(&#10;            requireContext(),&#10;            android.R.layout.simple_dropdown_item_1line,&#10;            contactTypes&#10;        )&#10;&#10;        spinner.setAdapter(adapter)&#10;        spinner.setText(&quot;Personal&quot;, false)&#10;    }&#10;&#10;    private fun openPhoneContactsSelection() {&#10;        // Add safety checks to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // PhoneContactsActivity was removed - show message that feature is not available&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Phone contacts import not available in this version&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error accessing phone contacts&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun makePhoneCall(phoneNumber: String) {&#10;        // Add comprehensive null checks and error handling&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // Enhanced call animation with haptic feedback&#10;            binding.root.performHapticFeedback(HapticFeedbackConstants.CONFIRM)&#10;&#10;            // Check for call permission&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    requireContext(),&#10;                    Manifest.permission.CALL_PHONE&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Direct call&#10;                    val callIntent = Intent(Intent.ACTION_CALL).apply {&#10;                        data = Uri.parse(&quot;tel:$phoneNumber&quot;)&#10;                    }&#10;                    if (callIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                        startActivity(callIntent)&#10;                    } else {&#10;                        // Fallback to dialer if direct call not available&#10;                        makeDialerCall(phoneNumber)&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    makeDialerCall(phoneNumber)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Fallback to dialer on any error&#10;            makeDialerCall(phoneNumber)&#10;        }&#10;    }&#10;&#10;    private fun makeDialerCall(phoneNumber: String) {&#10;        try {&#10;            // Use dialer as safe fallback&#10;            val dialIntent = Intent(Intent.ACTION_DIAL).apply {&#10;                data = Uri.parse(&quot;tel:$phoneNumber&quot;)&#10;            }&#10;            if (dialIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                startActivity(dialIntent)&#10;            } else if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;No dialer app available&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error making call&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun validateContactInput(name: String, phone: String): Boolean {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return false&#10;&#10;        if (name.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a contact name&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        if (phone.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        // Basic phone number validation&#10;        val phoneRegex = &quot;^[+]?[0-9\\s\\-\\(\\)]{7,15}$&quot;.toRegex()&#10;        if (!phone.matches(phoneRegex)) {&#10;            Snackbar.make(binding.root, &quot;Please enter a valid phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        return true&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;&#10;        _binding = null&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.ui.contacts&#10;&#10;import android.Manifest&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.TextWatcher&#10;import android.view.HapticFeedbackConstants&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.AutoCompleteTextView&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.firstaidapp.R&#10;import com.example.firstaidapp.data.models.ContactType&#10;import com.example.firstaidapp.data.models.EmergencyContact&#10;import com.example.firstaidapp.databinding.FragmentContactsBinding&#10;import com.google.android.material.snackbar.Snackbar&#10;import androidx.core.net.toUri&#10;&#10;class ContactsFragment : Fragment() {&#10;&#10;    private var _binding: FragmentContactsBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var viewModel: ContactsViewModel&#10;    private lateinit var contactsAdapter: ContactsAdapter&#10;&#10;    private val requestPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted: Boolean -&gt;&#10;        if (isGranted) {&#10;            // Permission granted, can make direct call&#10;            Snackbar.make(binding.root, &quot;Permission granted! Tap call button again to make direct call&quot;, Snackbar.LENGTH_SHORT).show()&#10;        } else {&#10;            Snackbar.make(binding.root, &quot;Using dialer instead&quot;, Snackbar.LENGTH_SHORT).show()&#10;        }&#10;    }&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentContactsBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        setupViewModel()&#10;        setupRecyclerView()&#10;        setupObservers()&#10;        setupClickListeners()&#10;        setupSearchFunctionality()&#10;    }&#10;&#10;    private fun setupViewModel() {&#10;        val factory = ContactsViewModelFactory(requireActivity().application)&#10;        viewModel = ViewModelProvider(this, factory)[ContactsViewModel::class.java]&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        contactsAdapter = ContactsAdapter { contact -&gt;&#10;            makePhoneCall(contact.phoneNumber)&#10;        }&#10;&#10;        binding.rvContacts.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = contactsAdapter&#10;        }&#10;    }&#10;&#10;    private fun setupObservers() {&#10;        viewModel.allContacts.observe(viewLifecycleOwner) { contacts -&gt;&#10;            contactsAdapter.submitList(contacts)&#10;        }&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        binding.btnSettings.setOnClickListener {&#10;            // Use basic navigation instead of SafeArgs for compatibility&#10;            findNavController().navigate(R.id.navigation_settings)&#10;        }&#10;&#10;        binding.fabAddContact.setOnClickListener {&#10;            showAddContactDialog()&#10;        }&#10;    }&#10;&#10;    private fun setupSearchFunctionality() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return&#10;&#10;        binding.etSearchContacts.addTextChangedListener(object : TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;                // Add null check&#10;                if (_binding == null) return&#10;&#10;                val query = s.toString()&#10;&#10;                // Removed all animations - immediate search instead&#10;                if (query.isNotEmpty()) {&#10;                    try {&#10;                        viewModel.searchContacts(query)&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                } else {&#10;                    try {&#10;                        viewModel.clearSearch()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                    }&#10;                }&#10;            }&#10;&#10;            override fun afterTextChanged(s: Editable?) {}&#10;        })&#10;&#10;        // Removed focus animations - basic functionality only&#10;        binding.etSearchContacts.setOnFocusChangeListener { view, hasFocus -&gt;&#10;            if (_binding == null) return@setOnFocusChangeListener&#10;            // No animations - just basic elevation change&#10;            if (hasFocus) {&#10;                view.elevation = 8f&#10;            } else {&#10;                view.elevation = 2f&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showAddContactDialog() {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            val dialogView = LayoutInflater.from(requireContext())&#10;                .inflate(R.layout.dialog_add_contact, null)&#10;&#10;            val dialog = androidx.appcompat.app.AlertDialog.Builder(requireContext())&#10;                .setView(dialogView)&#10;                .create()&#10;&#10;            // Get dialog views&#10;            val etContactName = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etContactName)&#10;            val etPhoneNumber = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etPhoneNumber)&#10;            val etRelationship = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etRelationship)&#10;            val spinnerContactType = dialogView.findViewById&lt;AutoCompleteTextView&gt;(R.id.spinnerContactType)&#10;            val etNotes = dialogView.findViewById&lt;com.google.android.material.textfield.TextInputEditText&gt;(R.id.etNotes)&#10;            val btnImportFromPhone = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnImportFromPhone)&#10;            val btnCancel = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnCancel)&#10;            val btnSave = dialogView.findViewById&lt;com.google.android.material.button.MaterialButton&gt;(R.id.btnSave)&#10;&#10;            // Null checks for all views&#10;            if (etContactName == null || etPhoneNumber == null || spinnerContactType == null ||&#10;                btnImportFromPhone == null || btnCancel == null || btnSave == null) {&#10;                return&#10;            }&#10;&#10;            // Setup contact type dropdown&#10;            setupContactTypeDropdown(spinnerContactType)&#10;&#10;            // Setup click listeners with null checks&#10;            btnImportFromPhone.setOnClickListener {&#10;                dialog.dismiss()&#10;                if (isAdded &amp;&amp; _binding != null) {&#10;                    openPhoneContactsSelection()&#10;                }&#10;            }&#10;&#10;            btnCancel.setOnClickListener {&#10;                dialog.dismiss()&#10;            }&#10;&#10;            btnSave.setOnClickListener {&#10;                if (!isAdded || _binding == null) {&#10;                    dialog.dismiss()&#10;                    return@setOnClickListener&#10;                }&#10;&#10;                val name = etContactName.text?.toString()?.trim() ?: &quot;&quot;&#10;                val phone = etPhoneNumber.text?.toString()?.trim() ?: &quot;&quot;&#10;                val relationship = etRelationship.text?.toString()?.trim() ?: &quot;&quot;&#10;                val typeString = spinnerContactType.text?.toString() ?: &quot;Personal&quot;&#10;                val notes = etNotes.text?.toString()?.trim() ?: &quot;&quot;&#10;&#10;                if (validateContactInput(name, phone)) {&#10;                    val contactType = when (typeString) {&#10;                        &quot;Emergency Service&quot; -&gt; ContactType.EMERGENCY_SERVICE&#10;                        &quot;Poison Control&quot; -&gt; ContactType.POISON_CONTROL&#10;                        &quot;Hospital&quot; -&gt; ContactType.HOSPITAL&#10;                        &quot;Police&quot; -&gt; ContactType.POLICE&#10;                        &quot;Fire Department&quot; -&gt; ContactType.FIRE_DEPARTMENT&#10;                        &quot;Family&quot; -&gt; ContactType.FAMILY&#10;                        &quot;Doctor&quot; -&gt; ContactType.DOCTOR&#10;                        &quot;Veterinarian&quot; -&gt; ContactType.VETERINARIAN&#10;                        &quot;Other&quot; -&gt; ContactType.OTHER&#10;                        else -&gt; ContactType.PERSONAL&#10;                    }&#10;&#10;                    val contact = EmergencyContact(&#10;                        name = name,&#10;                        phoneNumber = phone,&#10;                        relationship = relationship,&#10;                        type = contactType,&#10;                        notes = notes&#10;                    )&#10;&#10;                    try {&#10;                        viewModel.addContact(contact)&#10;&#10;                        // Removed animation - show immediate success message&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Contact added successfully!&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;&#10;                        dialog.dismiss()&#10;                    } catch (e: Exception) {&#10;                        e.printStackTrace()&#10;                        if (_binding != null) {&#10;                            Snackbar.make(binding.root, &quot;Error adding contact: ${e.message}&quot;, Snackbar.LENGTH_SHORT).show()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            dialog.show()&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error opening add contact dialog&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupContactTypeDropdown(spinner: AutoCompleteTextView) {&#10;        val contactTypes = arrayOf(&#10;            &quot;Personal&quot;,&#10;            &quot;Family&quot;,&#10;            &quot;Emergency Service&quot;,&#10;            &quot;Hospital&quot;,&#10;            &quot;Police&quot;,&#10;            &quot;Fire Department&quot;,&#10;            &quot;Poison Control&quot;,&#10;            &quot;Doctor&quot;,&#10;            &quot;Veterinarian&quot;,&#10;            &quot;Other&quot;&#10;        )&#10;&#10;        val adapter = android.widget.ArrayAdapter(&#10;            requireContext(),&#10;            android.R.layout.simple_dropdown_item_1line,&#10;            contactTypes&#10;        )&#10;&#10;        spinner.setAdapter(adapter)&#10;        spinner.setText(&quot;Personal&quot;, false)&#10;    }&#10;&#10;    private fun openPhoneContactsSelection() {&#10;        // Add safety checks to prevent crashes&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // PhoneContactsActivity was removed - show message that feature is not available&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Phone contacts import not available in this version&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error accessing phone contacts&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun makePhoneCall(phoneNumber: String) {&#10;        // Add comprehensive null checks and error handling&#10;        if (_binding == null || !isAdded) return&#10;&#10;        try {&#10;            // Enhanced call animation with haptic feedback&#10;            binding.root.performHapticFeedback(HapticFeedbackConstants.CONFIRM)&#10;&#10;            // Check for call permission&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    requireContext(),&#10;                    Manifest.permission.CALL_PHONE&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Direct call&#10;                    val callIntent = Intent(Intent.ACTION_CALL).apply {&#10;                        data = &quot;tel:$phoneNumber&quot;.toUri()&#10;                    }&#10;                    if (callIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                        startActivity(callIntent)&#10;                    } else {&#10;                        // Fallback to dialer if direct call not available&#10;                        makeDialerCall(phoneNumber)&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    makeDialerCall(phoneNumber)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            // Fallback to dialer on any error&#10;            makeDialerCall(phoneNumber)&#10;        }&#10;    }&#10;&#10;    private fun makeDialerCall(phoneNumber: String) {&#10;        try {&#10;            // Use dialer as safe fallback&#10;            val dialIntent = Intent(Intent.ACTION_DIAL).apply {&#10;                data = Uri.parse(&quot;tel:$phoneNumber&quot;)&#10;            }&#10;            if (dialIntent.resolveActivity(requireContext().packageManager) != null) {&#10;                startActivity(dialIntent)&#10;            } else if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;No dialer app available&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        } catch (e: Exception) {&#10;            e.printStackTrace()&#10;            if (_binding != null) {&#10;                Snackbar.make(binding.root, &quot;Error making call&quot;, Snackbar.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun validateContactInput(name: String, phone: String): Boolean {&#10;        // Add null check to prevent crashes&#10;        if (_binding == null) return false&#10;&#10;        if (name.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a contact name&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        if (phone.isEmpty()) {&#10;            Snackbar.make(binding.root, &quot;Please enter a phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        // Basic phone number validation&#10;        val phoneRegex = &quot;^[+]?[0-9\\s\\-\\(\\)]{7,15}$&quot;.toRegex()&#10;        if (!phone.matches(phoneRegex)) {&#10;            Snackbar.make(binding.root, &quot;Please enter a valid phone number&quot;, Snackbar.LENGTH_SHORT).show()&#10;            return false&#10;        }&#10;&#10;        return true&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;&#10;        _binding = null&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/guide/GuideDetailFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/guide/GuideDetailFragment.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.guide&#10;&#10;import android.R&#10;import android.app.Dialog&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.firstaidapp.databinding.FragmentGuideDetailBinding&#10;import com.example.firstaidapp.ui.home.PhotoMapper&#10;import java.io.IOException&#10;&#10;class GuideDetailFragment : Fragment() {&#10;&#10;    private var _binding: FragmentGuideDetailBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var viewModel: GuideDetailViewModel&#10;    private lateinit var stepsAdapter: GuideStepsAdapter&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentGuideDetailBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        setupViewModel()&#10;        setupRecyclerView()&#10;        setupObservers()&#10;        setupClickListeners()&#10;&#10;        // Get guide ID from arguments&#10;        val guideId = arguments?.getString(&quot;guide_id&quot;) ?: &quot;&quot;&#10;        if (guideId.isNotEmpty()) {&#10;            viewModel.loadGuide(guideId)&#10;        }&#10;    }&#10;&#10;    private fun setupViewModel() {&#10;        val factory = GuideDetailViewModelFactory(requireActivity().application)&#10;        viewModel = ViewModelProvider(this, factory)[GuideDetailViewModel::class.java]&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        stepsAdapter = GuideStepsAdapter()&#10;&#10;        binding.rvSteps.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = stepsAdapter&#10;        }&#10;    }&#10;&#10;    private fun setupObservers() {&#10;        viewModel.guide.observe(viewLifecycleOwner) { guide -&gt;&#10;            guide?.let {&#10;                binding.tvGuideTitle.text = it.title&#10;                binding.tvCategory.text = it.category&#10;                binding.tvSeverity.text = it.severity&#10;                binding.tvDescription.text = it.description&#10;                binding.tvWarnings.text = it.warnings.joinToString(&quot;\n• &quot;, &quot;• &quot;)&#10;                binding.tvWhenToCall.text = it.whenToCallEmergency&#10;&#10;                stepsAdapter.submitList(it.steps)&#10;&#10;                // Load demonstration photo for this guide&#10;                loadGuidePhoto(it.title)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadGuidePhoto(guideTitle: String) {&#10;        val photoPath = PhotoMapper.getPhotoForGuide(guideTitle)&#10;&#10;        if (photoPath != null) {&#10;            try {&#10;                // Try to load the photo from assets&#10;                val inputStream = requireContext().assets.open(photoPath)&#10;                val drawable = android.graphics.drawable.Drawable.createFromStream(inputStream, null)&#10;&#10;                if (drawable != null) {&#10;                    binding.ivGuidePhoto.setImageDrawable(drawable)&#10;                    binding.cvPhotoDemo.visibility = View.VISIBLE&#10;                } else {&#10;                    // If photo loading fails, hide the photo section&#10;                    binding.cvPhotoDemo.visibility = View.GONE&#10;                }&#10;&#10;                inputStream.close()&#10;&#10;            } catch (e: IOException) {&#10;                // Photo file doesn't exist, hide the photo section&#10;                binding.cvPhotoDemo.visibility = View.GONE&#10;            }&#10;        } else {&#10;            // No photo mapping found, hide the photo section&#10;            binding.cvPhotoDemo.visibility = View.GONE&#10;        }&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        // Emergency call button&#10;        binding.btnCallEmergency.setOnClickListener {&#10;            makeEmergencyCall()&#10;        }&#10;            // TODO: Implement full-screen photo view&#10;            // For now, just show a toast&#10;            android.widget.Toast.makeText(&#10;                requireContext(),&#10;                &quot;Full photo view - Coming Soon&quot;,&#10;                android.widget.Toast.LENGTH_SHORT&#10;            ).show()&#10;        // Full photo view click listener&#10;        binding.tvViewFullPhoto.setOnClickListener {&#10;            showFullSizePhoto()&#10;        }&#10;&#10;        // Handle photo tap for full-size viewing&#10;        binding.ivGuidePhoto.setOnClickListener {&#10;            showFullSizePhoto()&#10;        }&#10;        // TODO: Implement full-screen photo viewer dialog&#10;        // For now, we can use a simple dialog or navigate to a full-screen fragment&#10;        // This can be enhanced later with pinch-to-zoom functionality&#10;        &#10;        dialog.setContentView(imageView)&#10;        dialog.show()&#10;    }&#10;&#10;    private fun makeEmergencyCall() {&#10;        try {&#10;            val intent = Intent(Intent.ACTION_CALL).apply {&#10;                data = Uri.parse(&quot;tel:911&quot;) // Using 911 as default emergency number&#10;            }&#10;            startActivity(intent)&#10;        } catch (e: Exception) {&#10;            // If calling fails, open dialer instead&#10;            val intent = Intent(Intent.ACTION_DIAL).apply {&#10;                data = Uri.parse(&quot;tel:911&quot;)&#10;            }&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.ui.guide&#10;&#10;import android.app.Dialog&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import androidx.core.net.toUri&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.ViewModelProvider&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import com.example.firstaidapp.databinding.FragmentGuideDetailBinding&#10;import com.example.firstaidapp.ui.home.PhotoMapper&#10;import java.io.IOException&#10;&#10;class GuideDetailFragment : Fragment() {&#10;&#10;    private var _binding: FragmentGuideDetailBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private lateinit var viewModel: GuideDetailViewModel&#10;    private lateinit var stepsAdapter: GuideStepsAdapter&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentGuideDetailBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        setupViewModel()&#10;        setupRecyclerView()&#10;        setupObservers()&#10;        setupClickListeners()&#10;&#10;        // Get guide ID from arguments&#10;        val guideId = arguments?.getString(&quot;guide_id&quot;) ?: &quot;&quot;&#10;        if (guideId.isNotEmpty()) {&#10;            viewModel.loadGuide(guideId)&#10;        }&#10;    }&#10;&#10;    private fun setupViewModel() {&#10;        val factory = GuideDetailViewModelFactory(requireActivity().application)&#10;        viewModel = ViewModelProvider(this, factory)[GuideDetailViewModel::class.java]&#10;    }&#10;&#10;    private fun setupRecyclerView() {&#10;        stepsAdapter = GuideStepsAdapter()&#10;&#10;        binding.rvSteps.apply {&#10;            layoutManager = LinearLayoutManager(requireContext())&#10;            adapter = stepsAdapter&#10;        }&#10;    }&#10;&#10;    private fun setupObservers() {&#10;        viewModel.guide.observe(viewLifecycleOwner) { guide -&gt;&#10;            guide?.let {&#10;                binding.tvGuideTitle.text = it.title&#10;                binding.tvCategory.text = it.category&#10;                binding.tvSeverity.text = it.severity&#10;                binding.tvDescription.text = it.description&#10;                binding.tvWarnings.text = it.warnings.joinToString(&quot;\n• &quot;, &quot;• &quot;)&#10;                binding.tvWhenToCall.text = it.whenToCallEmergency&#10;&#10;                stepsAdapter.submitList(it.steps)&#10;&#10;                // Load demonstration photo for this guide&#10;                loadGuidePhoto(it.title)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun loadGuidePhoto(guideTitle: String) {&#10;        val photoPath = PhotoMapper.getPhotoForGuide(guideTitle)&#10;&#10;        if (photoPath != null) {&#10;            try {&#10;                // Try to load the photo from assets&#10;                val inputStream = requireContext().assets.open(photoPath)&#10;                val drawable = android.graphics.drawable.Drawable.createFromStream(inputStream, null)&#10;&#10;                if (drawable != null) {&#10;                    binding.ivGuidePhoto.setImageDrawable(drawable)&#10;                    binding.cvPhotoDemo.visibility = View.VISIBLE&#10;                } else {&#10;                    // If photo loading fails, hide the photo section&#10;                    binding.cvPhotoDemo.visibility = View.GONE&#10;                }&#10;&#10;                inputStream.close()&#10;&#10;            } catch (e: IOException) {&#10;                // Photo file doesn't exist, hide the photo section&#10;                binding.cvPhotoDemo.visibility = View.GONE&#10;            }&#10;        } else {&#10;            // No photo mapping found, hide the photo section&#10;            binding.cvPhotoDemo.visibility = View.GONE&#10;        }&#10;    }&#10;&#10;    private fun setupClickListeners() {&#10;        // Emergency call button&#10;        binding.btnCallEmergency.setOnClickListener {&#10;            makeEmergencyCall()&#10;        }&#10;&#10;        // Full photo view click listener&#10;        binding.tvViewFullPhoto.setOnClickListener {&#10;            showFullSizePhoto()&#10;        }&#10;&#10;        // Handle photo tap for full-size viewing&#10;        binding.ivGuidePhoto.setOnClickListener {&#10;            showFullSizePhoto()&#10;        }&#10;    }&#10;&#10;    private fun showFullSizePhoto() {&#10;        // Create and show a full-screen image dialog&#10;        val dialog = Dialog(requireContext(), android.R.style.Theme_Black_NoTitleBar_Fullscreen)&#10;        val imageView = ImageView(requireContext())&#10;        imageView.scaleType = ImageView.ScaleType.CENTER_INSIDE&#10;        &#10;        // Set the same image as the guide photo&#10;        binding.ivGuidePhoto.drawable?.let { drawable -&gt;&#10;            imageView.setImageDrawable(drawable)&#10;        }&#10;        &#10;        // Close dialog on tap&#10;        imageView.setOnClickListener {&#10;            dialog.dismiss()&#10;        }&#10;        &#10;        dialog.setContentView(imageView)&#10;        dialog.show()&#10;    }&#10;&#10;    private fun makeEmergencyCall() {&#10;        try {&#10;            val intent = Intent(Intent.ACTION_CALL).apply {&#10;                data = &quot;tel:911&quot;.toUri() // Using 911 as default emergency number&#10;            }&#10;            startActivity(intent)&#10;        } catch (e: Exception) {&#10;            // If calling fails, open dialer instead&#10;            val intent = Intent(Intent.ACTION_DIAL).apply {&#10;                data = &quot;tel:911&quot;.toUri()&#10;            }&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/guides/GuideStepAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/guides/GuideStepAdapter.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.guides&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.animation.AnimationUtils&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.firstaidapp.R&#10;import com.example.firstaidapp.data.models.GuideStep&#10;import com.example.firstaidapp.data.models.StepType&#10;import com.example.firstaidapp.databinding.ItemGuideStepBinding&#10;&#10;class GuideStepAdapter(&#10;    private val onStepCompleted: (GuideStep) -&gt; Unit,&#10;    private val onStepExpanded: (GuideStep, Boolean) -&gt; Unit&#10;) : ListAdapter&lt;GuideStep, GuideStepAdapter.StepViewHolder&gt;(StepDiffCallback()) {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StepViewHolder {&#10;        val binding = ItemGuideStepBinding.inflate(&#10;            LayoutInflater.from(parent.context),&#10;            parent,&#10;            false&#10;        )&#10;        return StepViewHolder(binding)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: StepViewHolder, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    inner class StepViewHolder(&#10;        private val binding: ItemGuideStepBinding&#10;    ) : RecyclerView.ViewHolder(binding.root) {&#10;&#10;        fun bind(step: GuideStep) {&#10;            binding.apply {&#10;                // Set step number&#10;                tvStepNumber.text = step.stepNumber.toString()&#10;&#10;                // Set step title and description&#10;                tvStepTitle.text = step.title&#10;                tvStepDescription.text = step.description&#10;&#10;                // Set step type icon based on step type&#10;                when (step.stepType) {&#10;                    StepType.CHECK -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_search)&#10;                    StepType.ACTION -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                    StepType.CALL -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_phone)&#10;                    StepType.REPEAT -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_repeat)&#10;                    StepType.ASSESSMENT -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_search)&#10;                    StepType.EMERGENCY_CALL -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_phone)&#10;                    StepType.POSITIONING -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                    StepType.MONITORING -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                    StepType.SAFETY -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_warning)&#10;                    StepType.FOLLOW_UP -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                }&#10;&#10;                // Show/hide duration if available&#10;                step.iconRes?.let {&#10;                    ivStepTypeIcon.setImageResource(it)&#10;                }&#10;&#10;                // Show/hide duration if available&#10;                if (!step.duration.isNullOrEmpty()) {&#10;                    tvDuration.visibility = View.VISIBLE&#10;                    tvDuration.text = step.duration&#10;                } else {&#10;                    tvDuration.visibility = View.GONE&#10;                }&#10;&#10;                // Show critical warning indicator for critical steps&#10;                ivCriticalWarning.visibility = if (step.isCritical) View.VISIBLE else View.GONE&#10;&#10;                // Handle step image if available&#10;                step.imageRes?.let { imageResId -&gt;&#10;                    cardStepImage.visibility = View.VISIBLE&#10;                    ivStepImage.setImageResource(imageResId)&#10;                } ?: run {&#10;                    cardStepImage.visibility = View.GONE&#10;                }&#10;&#10;                // Handle detailed instructions&#10;                if (!step.detailedInstructions.isNullOrEmpty()) {&#10;                    tvDetailedInstructions.text = step.detailedInstructions&#10;                } else {&#10;                    layoutDetailedInstructions.visibility = View.GONE&#10;                }&#10;&#10;                // Handle required tools&#10;                if (!step.requiredTools.isNullOrEmpty()) {&#10;                    // TODO: Populate tools flexbox layout&#10;                    }&#10;                } else {&#10;                    layoutRequiredTools.visibility = View.GONE&#10;                }&#10;&#10;                // Handle tips&#10;                if (!step.tips.isNullOrEmpty()) {&#10;                    // TODO: Populate tips section&#10;                    }&#10;                } else {&#10;                    layoutTips.visibility = View.GONE&#10;                }&#10;&#10;                // Handle warnings if available&#10;                if (!step.warnings.isNullOrEmpty()) {&#10;                    // Show warning section if available&#10;                    step.warnings?.forEach { warning -&gt;&#10;                        // Add warning to UI (implementation depends on layout)&#10;                    }&#10;                }&#10;&#10;                // Set up click listeners for expansion/interaction&#10;                setupStepInteractions(step)&#10;&#10;                // Apply entrance animation&#10;                applyEntranceAnimation()&#10;            }&#10;        }&#10;&#10;        private fun setupStepInteractions(step: GuideStep) {&#10;            binding.apply {&#10;                // Expandable content toggle&#10;                cardStep.setOnClickListener {&#10;                    toggleExpandedContent(step)&#10;                }&#10;&#10;                // Step completion marking&#10;                tvStepNumber.setOnClickListener {&#10;                    markStepCompleted(step)&#10;                }&#10;&#10;                // Video play button (if applicable)&#10;                fabPlayVideo.setOnClickListener {&#10;                    // TODO: Implement video playback&#10;                }&#10;            }&#10;        }&#10;&#10;        private fun toggleExpandedContent(step: GuideStep) {&#10;            binding.apply {&#10;                val isExpanded = layoutDetailedInstructions.visibility == View.VISIBLE&#10;&#10;                if (isExpanded) {&#10;                    // Collapse with animation&#10;                    layoutDetailedInstructions.animate()&#10;                        .alpha(0f)&#10;                        .setDuration(200)&#10;                        .withEndAction {&#10;                            layoutDetailedInstructions.visibility = View.GONE&#10;                        }&#10;                        .start()&#10;                } else {&#10;                    // Expand with animation&#10;                    layoutDetailedInstructions.visibility = View.VISIBLE&#10;                    layoutDetailedInstructions.alpha = 0f&#10;                    layoutDetailedInstructions.animate()&#10;                        .alpha(1f)&#10;                        .setDuration(200)&#10;                        .start()&#10;                }&#10;&#10;                onStepExpanded(step, !isExpanded)&#10;            }&#10;        }&#10;&#10;        private fun markStepCompleted(step: GuideStep) {&#10;            binding.apply {&#10;                // Visual feedback for completion&#10;                tvStepNumber.animate()&#10;                    .scaleX(1.2f)&#10;                    .scaleY(1.2f)&#10;                    .setDuration(150)&#10;                    .withEndAction {&#10;                        tvStepNumber.animate()&#10;                            .scaleX(1f)&#10;                            .scaleY(1f)&#10;                            .setDuration(150)&#10;                            .start()&#10;                    }&#10;                    .start()&#10;&#10;                onStepCompleted(step)&#10;            }&#10;        }&#10;&#10;        private fun applyEntranceAnimation() {&#10;            binding.cardStep.apply {&#10;                alpha = 0f&#10;                translationY = 50f&#10;                animate()&#10;                    .alpha(1f)&#10;                    .translationY(0f)&#10;                    .setDuration(300)&#10;                    .setStartDelay((bindingAdapterPosition * 100).toLong())&#10;                    .start()&#10;            }&#10;        }&#10;    }&#10;&#10;    class StepDiffCallback : DiffUtil.ItemCallback&lt;GuideStep&gt;() {&#10;        override fun areItemsTheSame(oldItem: GuideStep, newItem: GuideStep): Boolean {&#10;            return oldItem.id == newItem.id&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: GuideStep, newItem: GuideStep): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.ui.guides&#10;&#10;import android.content.Intent&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.animation.AnimationUtils&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.net.toUri&#10;import androidx.recyclerview.widget.DiffUtil&#10;import androidx.recyclerview.widget.ListAdapter&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.firstaidapp.R&#10;import com.example.firstaidapp.data.models.GuideStep&#10;import com.example.firstaidapp.data.models.StepType&#10;import com.example.firstaidapp.databinding.ItemGuideStepBinding&#10;&#10;class GuideStepAdapter(&#10;    private val onStepCompleted: (GuideStep) -&gt; Unit,&#10;    private val onStepExpanded: (GuideStep, Boolean) -&gt; Unit&#10;) : ListAdapter&lt;GuideStep, GuideStepAdapter.StepViewHolder&gt;(StepDiffCallback()) {&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): StepViewHolder {&#10;        val binding = ItemGuideStepBinding.inflate(&#10;            LayoutInflater.from(parent.context),&#10;            parent,&#10;            false&#10;        )&#10;        return StepViewHolder(binding)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: StepViewHolder, position: Int) {&#10;        holder.bind(getItem(position))&#10;    }&#10;&#10;    inner class StepViewHolder(&#10;        private val binding: ItemGuideStepBinding&#10;    ) : RecyclerView.ViewHolder(binding.root) {&#10;&#10;        fun bind(step: GuideStep) {&#10;            binding.apply {&#10;                // Set step number&#10;                tvStepNumber.text = step.stepNumber.toString()&#10;&#10;                // Set step title and description&#10;                tvStepTitle.text = step.title&#10;                tvStepDescription.text = step.description&#10;&#10;                // Set step type icon based on step type&#10;                when (step.stepType) {&#10;                    StepType.CHECK -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_search)&#10;                    StepType.ACTION -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                    StepType.CALL -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_phone)&#10;                    StepType.REPEAT -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_repeat)&#10;                    StepType.ASSESSMENT -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_search)&#10;                    StepType.EMERGENCY_CALL -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_phone)&#10;                    StepType.POSITIONING -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                    StepType.MONITORING -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                    StepType.SAFETY -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_warning)&#10;                    StepType.FOLLOW_UP -&gt; ivStepTypeIcon.setImageResource(R.drawable.ic_action)&#10;                }&#10;&#10;                // Show/hide duration if available&#10;                step.iconRes?.let {&#10;                    ivStepTypeIcon.setImageResource(it)&#10;                }&#10;&#10;                // Show/hide duration if available&#10;                if (!step.duration.isNullOrEmpty()) {&#10;                    tvDuration.visibility = View.VISIBLE&#10;                    tvDuration.text = step.duration&#10;                } else {&#10;                    tvDuration.visibility = View.GONE&#10;                }&#10;&#10;                // Show critical warning indicator for critical steps&#10;                ivCriticalWarning.visibility = if (step.isCritical) View.VISIBLE else View.GONE&#10;&#10;                // Handle step image if available&#10;                step.imageRes?.let { imageResId -&gt;&#10;                    cardStepImage.visibility = View.VISIBLE&#10;                    ivStepImage.setImageResource(imageResId)&#10;                } ?: run {&#10;                    cardStepImage.visibility = View.GONE&#10;                }&#10;&#10;                // Handle detailed instructions&#10;                if (!step.detailedInstructions.isNullOrEmpty()) {&#10;                    tvDetailedInstructions.text = step.detailedInstructions&#10;                } else {&#10;                    layoutDetailedInstructions.visibility = View.GONE&#10;                }&#10;&#10;                // Handle required tools&#10;                if (!step.requiredTools.isNullOrEmpty()) {&#10;                    layoutRequiredTools.visibility = View.VISIBLE&#10;                    // Clear any existing tools&#10;                    flexboxTools.removeAllViews()&#10;                    // Add each tool as a chip to the flexbox layout&#10;                    step.requiredTools.forEach { tool -&gt;&#10;                        val chipView = layoutInflater.inflate(R.layout.chip_tool, flexboxTools, false)&#10;                        chipView.findViewById&lt;TextView&gt;(R.id.tvToolName)?.text = tool&#10;                        flexboxTools.addView(chipView)&#10;                    }&#10;                } else {&#10;                    layoutRequiredTools.visibility = View.GONE&#10;                }&#10;&#10;                // Handle tips&#10;                if (!step.tips.isNullOrEmpty()) {&#10;                    layoutTips.visibility = View.VISIBLE&#10;                    // Clear any existing tips&#10;                    layoutTipsContainer.removeAllViews()&#10;                    // Add each tip as a separate view&#10;                    step.tips.forEach { tip -&gt;&#10;                        val tipView = layoutInflater.inflate(R.layout.item_tip, layoutTipsContainer, false)&#10;                        tipView.findViewById&lt;TextView&gt;(R.id.tvTipText)?.text = tip&#10;                        layoutTipsContainer.addView(tipView)&#10;                    }&#10;                } else {&#10;                    layoutTips.visibility = View.GONE&#10;                }&#10;&#10;                // Handle warnings if available&#10;                if (!step.warnings.isNullOrEmpty()) {&#10;                    // Show warning section if available&#10;                    step.warnings?.forEach { warning -&gt;&#10;                        // Add warning to UI (implementation depends on layout)&#10;                    }&#10;                }&#10;&#10;                // Set up click listeners for expansion/interaction&#10;                setupStepInteractions(step)&#10;&#10;                // Apply entrance animation&#10;                applyEntranceAnimation()&#10;            }&#10;        }&#10;&#10;        private fun setupStepInteractions(step: GuideStep) {&#10;            binding.apply {&#10;                // Expandable content toggle&#10;                cardStep.setOnClickListener {&#10;                    toggleExpandedContent(step)&#10;                }&#10;&#10;                // Step completion marking&#10;                tvStepNumber.setOnClickListener {&#10;                    markStepCompleted(step)&#10;                }&#10;&#10;                // Video play button (if applicable)&#10;                fabPlayVideo.setOnClickListener {&#10;                    // Open video in external player or show not available message&#10;                    step.videoUrl?.let { videoUrl -&gt;&#10;                        val intent = Intent(Intent.ACTION_VIEW, videoUrl.toUri())&#10;                        binding.root.context.startActivity(intent)&#10;                    } ?: run {&#10;                        // Show message that video is not available&#10;                        Toast.makeText(binding.root.context, &quot;Video not available&quot;, Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        private fun toggleExpandedContent(step: GuideStep) {&#10;            binding.apply {&#10;                val isExpanded = layoutDetailedInstructions.visibility == View.VISIBLE&#10;&#10;                if (isExpanded) {&#10;                    // Collapse with animation&#10;                    layoutDetailedInstructions.animate()&#10;                        .alpha(0f)&#10;                        .setDuration(200)&#10;                        .withEndAction {&#10;                            layoutDetailedInstructions.visibility = View.GONE&#10;                        }&#10;                        .start()&#10;                } else {&#10;                    // Expand with animation&#10;                    layoutDetailedInstructions.visibility = View.VISIBLE&#10;                    layoutDetailedInstructions.alpha = 0f&#10;                    layoutDetailedInstructions.animate()&#10;                        .alpha(1f)&#10;                        .setDuration(200)&#10;                        .start()&#10;                }&#10;&#10;                onStepExpanded(step, !isExpanded)&#10;            }&#10;        }&#10;&#10;        private fun markStepCompleted(step: GuideStep) {&#10;            binding.apply {&#10;                // Visual feedback for completion&#10;                tvStepNumber.animate()&#10;                    .scaleX(1.2f)&#10;                    .scaleY(1.2f)&#10;                    .setDuration(150)&#10;                    .withEndAction {&#10;                        tvStepNumber.animate()&#10;                            .scaleX(1f)&#10;                            .scaleY(1f)&#10;                            .setDuration(150)&#10;                            .start()&#10;                    }&#10;                    .start()&#10;&#10;                onStepCompleted(step)&#10;            }&#10;        }&#10;&#10;        private fun applyEntranceAnimation() {&#10;            binding.cardStep.apply {&#10;                alpha = 0f&#10;                translationY = 50f&#10;                animate()&#10;                    .alpha(1f)&#10;                    .translationY(0f)&#10;                    .setDuration(300)&#10;                    .setStartDelay((bindingAdapterPosition * 100).toLong())&#10;                    .start()&#10;            }&#10;        }&#10;    }&#10;&#10;    class StepDiffCallback : DiffUtil.ItemCallback&lt;GuideStep&gt;() {&#10;        override fun areItemsTheSame(oldItem: GuideStep, newItem: GuideStep): Boolean {&#10;            return oldItem.id == newItem.id&#10;        }&#10;&#10;        override fun areContentsTheSame(oldItem: GuideStep, newItem: GuideStep): Boolean {&#10;            return oldItem == newItem&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.home&#10;&#10;import android.app.Application&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.firstaidapp.data.database.AppDatabase&#10;import com.example.firstaidapp.data.models.FirstAidGuide&#10;import com.example.firstaidapp.data.repository.GuideRepository&#10;import com.example.firstaidapp.utils.DataInitializer&#10;import kotlinx.coroutines.launch&#10;&#10;class HomeViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private lateinit var repository: GuideRepository&#10;&#10;    private val _categorizedItems = MutableLiveData&lt;List&lt;CategoryItem&gt;&gt;()&#10;    val categorizedItems: LiveData&lt;List&lt;CategoryItem&gt;&gt; = _categorizedItems&#10;&#10;    private val expandedCategories = mutableSetOf&lt;String&gt;()&#10;&#10;    private val _guides = MutableLiveData&lt;List&lt;FirstAidGuide&gt;&gt;()&#10;&#10;    private val _searchResults = MutableLiveData&lt;List&lt;FirstAidGuide&gt;&gt;()&#10;    val searchResults: LiveData&lt;List&lt;FirstAidGuide&gt;&gt; = _searchResults&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            val database = AppDatabase.getDatabase(application)&#10;            repository = GuideRepository(&#10;                database.guideDao(),&#10;                database.contactDao(),&#10;                database.searchDao()&#10;            )&#10;&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Forcing immediate reinitialization&quot;)&#10;            DataInitializer(getApplication()).forceImmediateReinitialization()&#10;&#10;            repository.allGuides.observeForever { guides -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Total guides available: ${guides.size}&quot;)&#10;                _guides.value = guides&#10;                updateCategorizedItems(guides)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCategorizedItems(guides: List&lt;FirstAidGuide&gt;) {&#10;        val categorizedGuides = GuideCategories.getCategorizedGuides(guides)&#10;        val items = mutableListOf&lt;CategoryItem&gt;()&#10;&#10;        categorizedGuides.forEach { category -&gt;&#10;            items.add(&#10;                CategoryItem.CategoryHeader(&#10;                    title = category.title,&#10;                    icon = category.icon,&#10;                    description = category.description,&#10;                    isExpanded = expandedCategories.contains(category.title),&#10;                    guideCount = category.guides.size&#10;                )&#10;            )&#10;&#10;            if (expandedCategories.contains(category.title)) {&#10;                items.addAll(category.guides.map { CategoryItem.GuideItem(it) })&#10;            }&#10;        }&#10;&#10;        _categorizedItems.value = items&#10;    }&#10;&#10;    fun toggleCategory(categoryTitle: String) {&#10;        if (expandedCategories.contains(categoryTitle)) {&#10;            expandedCategories.remove(categoryTitle)&#10;        } else {&#10;            expandedCategories.add(categoryTitle)&#10;        }&#10;        _guides.value?.let { updateCategorizedItems(it) }&#10;    }&#10;&#10;    fun searchGuides(query: String) {&#10;        viewModelScope.launch {&#10;            _searchResults.value = if (query.isNotEmpty()) {&#10;                repository.searchGuidesList(query)&#10;            } else {&#10;                emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearSearch() {&#10;        _searchResults.value = emptyList()&#10;    }&#10;&#10;    fun callEmergencyServices(context: Context) {&#10;        val intent = Intent(Intent.ACTION_DIAL).apply {&#10;            data = Uri.parse(&quot;tel:911&quot;)&#10;        }&#10;        context.startActivity(intent)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.firstaidapp.ui.home&#10;&#10;import android.app.Application&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.net.Uri&#10;import android.util.Log&#10;import androidx.core.net.toUri&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.firstaidapp.data.database.AppDatabase&#10;import com.example.firstaidapp.data.models.FirstAidGuide&#10;import com.example.firstaidapp.data.repository.GuideRepository&#10;import com.example.firstaidapp.utils.DataInitializer&#10;import kotlinx.coroutines.launch&#10;&#10;class HomeViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    private lateinit var repository: GuideRepository&#10;&#10;    private val _categorizedItems = MutableLiveData&lt;List&lt;CategoryItem&gt;&gt;()&#10;    val categorizedItems: LiveData&lt;List&lt;CategoryItem&gt;&gt; = _categorizedItems&#10;&#10;    private val expandedCategories = mutableSetOf&lt;String&gt;()&#10;&#10;    private val _guides = MutableLiveData&lt;List&lt;FirstAidGuide&gt;&gt;()&#10;&#10;    private val _searchResults = MutableLiveData&lt;List&lt;FirstAidGuide&gt;&gt;()&#10;    val searchResults: LiveData&lt;List&lt;FirstAidGuide&gt;&gt; = _searchResults&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            val database = AppDatabase.getDatabase(application)&#10;            repository = GuideRepository(&#10;                database.guideDao(),&#10;                database.contactDao(),&#10;                database.searchDao()&#10;            )&#10;&#10;            Log.d(&quot;HomeViewModel&quot;, &quot;Forcing immediate reinitialization&quot;)&#10;            DataInitializer(getApplication()).forceImmediateReinitialization()&#10;&#10;            repository.allGuides.observeForever { guides -&gt;&#10;                Log.d(&quot;HomeViewModel&quot;, &quot;Total guides available: ${guides.size}&quot;)&#10;                _guides.value = guides&#10;                updateCategorizedItems(guides)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateCategorizedItems(guides: List&lt;FirstAidGuide&gt;) {&#10;        val categorizedGuides = GuideCategories.getCategorizedGuides(guides)&#10;        val items = mutableListOf&lt;CategoryItem&gt;()&#10;&#10;        categorizedGuides.forEach { category -&gt;&#10;            items.add(&#10;                CategoryItem.CategoryHeader(&#10;                    title = category.title,&#10;                    icon = category.icon,&#10;                    description = category.description,&#10;                    isExpanded = expandedCategories.contains(category.title),&#10;                    guideCount = category.guides.size&#10;                )&#10;            )&#10;&#10;            if (expandedCategories.contains(category.title)) {&#10;                items.addAll(category.guides.map { CategoryItem.GuideItem(it) })&#10;            }&#10;        }&#10;&#10;        _categorizedItems.value = items&#10;    }&#10;&#10;    fun toggleCategory(categoryTitle: String) {&#10;        if (expandedCategories.contains(categoryTitle)) {&#10;            expandedCategories.remove(categoryTitle)&#10;        } else {&#10;            expandedCategories.add(categoryTitle)&#10;        }&#10;        _guides.value?.let { updateCategorizedItems(it) }&#10;    }&#10;&#10;    fun searchGuides(query: String) {&#10;        viewModelScope.launch {&#10;            _searchResults.value = if (query.isNotEmpty()) {&#10;                repository.searchGuidesList(query)&#10;            } else {&#10;                emptyList()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearSearch() {&#10;        _searchResults.value = emptyList()&#10;    }&#10;&#10;    fun callEmergencyServices(context: Context) {&#10;        val intent = Intent(Intent.ACTION_DIAL).apply {&#10;            data = &quot;tel:911&quot;.toUri()&#10;        }&#10;        context.startActivity(intent)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/home/VideoMapper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/firstaidapp/ui/home/VideoMapper.kt" />
              <option name="originalContent" value="package com.example.firstaidapp.ui.home&#10;&#10;/**&#10; * Maps first aid guide titles to their corresponding MP4 video files&#10; * This provides real video demonstrations for better understanding&#10; */&#10;object VideoMapper {&#10;&#10;    private val videoMap = mapOf(&#10;        // Life-Threatening Emergencies - Critical procedure videos&#10;        &quot;CPR&quot; to &quot;videos/cpr_demonstration.mp4&quot;,&#10;        &quot;Choking&quot; to &quot;videos/choking_heimlich.mp4&quot;,&#10;        &quot;Heart Attack&quot; to &quot;videos/heart_attack_response.mp4&quot;,&#10;        &quot;Stroke&quot; to &quot;videos/stroke_fast_assessment.mp4&quot;,&#10;        &quot;Drowning&quot; to &quot;videos/drowning_rescue.mp4&quot;,&#10;&#10;        // Trauma &amp; Injuries - Medical procedure videos&#10;        &quot;Severe Bleeding&quot; to &quot;videos/bleeding_control.mp4&quot;,&#10;        &quot;Burns&quot; to &quot;videos/burns_treatment.mp4&quot;,&#10;        &quot;Fractures&quot; to &quot;videos/fracture_immobilization.mp4&quot;,&#10;        &quot;Sprains and Strains&quot; to &quot;videos/sprain_care.mp4&quot;,&#10;        &quot;Eye Injuries&quot; to &quot;videos/eye_injury_care.mp4&quot;,&#10;        &quot;Nosebleeds&quot; to &quot;videos/nosebleed_control.mp4&quot;,&#10;&#10;        // Medical Conditions - Emergency response videos&#10;        &quot;Allergic Reactions&quot; to &quot;videos/anaphylaxis_epipen.mp4&quot;,&#10;        &quot;Asthma Attack&quot; to &quot;videos/asthma_inhaler.mp4&quot;,&#10;        &quot;Diabetic Emergencies&quot; to &quot;videos/diabetes_response.mp4&quot;,&#10;        &quot;Seizures&quot; to &quot;videos/seizure_response.mp4&quot;,&#10;        &quot;Poisoning&quot; to &quot;videos/poisoning_response.mp4&quot;,&#10;        &quot;Shock&quot; to &quot;videos/shock_treatment.mp4&quot;,&#10;&#10;        // Environmental Emergencies - Hazard response videos&#10;        &quot;Hypothermia&quot; to &quot;videos/hypothermia_warming.mp4&quot;,&#10;        &quot;Heat Exhaustion&quot; to &quot;videos/heat_exhaustion_cooling.mp4&quot;,&#10;        &quot;Bites and Stings&quot; to &quot;videos/bites_stings_treatment.mp4&quot;&#10;    )&#10;&#10;    /**&#10;     * Get the appropriate video for a first aid guide&#10;     * Falls back to a generic instructional video if specific video not found&#10;     */&#10;    fun getVideoForGuide(guideTitle: String): String? {&#10;        // Try exact match first&#10;        videoMap[guideTitle]?.let { return it }&#10;&#10;        // Try partial matching for guides with complex names&#10;        videoMap.forEach { (key, video) -&gt;&#10;            if (guideTitle.contains(key, ignoreCase = true)) {&#10;                return video&#10;            }&#10;        }&#10;&#10;        // Default fallback video&#10;        return &quot;videos/general_first_aid.mp4&quot;&#10;    }&#10;&#10;    /**&#10;     * Check if video file exists (for fallback purposes)&#10;     */&#10;    fun hasVideo(videoPath: String?): Boolean {&#10;        return !videoPath.isNullOrBlank()&#10;    }&#10;&#10;    /**&#10;     * Get all available video paths for preloading&#10;     */&#10;    fun getAllVideoPaths(): List&lt;String&gt; {&#10;        return videoMap.values.toList()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// This file has been replaced by PhotoMapper.kt&#10;// All video functionality has been removed and replaced with photo support" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>